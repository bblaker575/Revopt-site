<script>
/* ================== Core config & utils ================== */
const DEFAULT_CSV = 'data/vsp_choice_master_v7_full_fixed.csv';
const REQUIRE_D_CODES_FOR_SV_AND_LINED_POLARIZED = true;

/* ---------- Price-anchored tiers ---------- */
const BETTER_CAP_OF_MAX = 0.75; // Better: <= 75% of MaxPrice (i.e., >=25% under)
const GOOD_CAP_OF_MAX   = 0.50; // Good:   <= 50% of MaxPrice

/* ---------- Fallback relaxers (stops empty cards) ---------- */
const CAP_RELAX_FACTOR  = 0.90; // if no hit at cap, retry at cap/0.90 (e.g., 0.75 -> 0.833)
/* You can set CAP_RELAX_FACTOR=1.0 to disable relaxing and accept blank tiers. */

const el = (id)=>document.getElementById(id);
const sum = (a)=>a.reduce((x,y)=>x+y,0);
const money = (v)=>`$${v.toFixed(2)}`;
const num = (v)=>{ const x=parseFloat(String(v??'').replace(/[^0-9.-]/g,'')); return isFinite(x)?x:0; };
const quickHash=(s)=>{ let h=2166136261>>>0; for(let i=0;i<s.length;i++){ h^=s.charCodeAt(i); h=Math.imul(h,16777619)>>>0; } return ('00000000'+h.toString(16)).slice(-8); };
const N = s => String(s||'').toLowerCase();

const isDCode  = r => /^d/i.test((r.code||'').trim());
const isPPhoto = r => /^p(m|r)/i.test((r.code||'').trim());
const isGlassBase = row => /glass/i.test(N(row?.enhancement || row?.subtype || ''));
const preferPhotoCodeForBase = row => (isGlassBase(row) ? 'PM' : 'PR');

// -------- Per-office preferences (persisted by URL ?office=slug) --------
const OFFICE_ID = new URLSearchParams(location.search).get('office') || 'default';
const PREF_KEY  = `pe-prefs-${OFFICE_ID}`;
const loadPrefs = () => { try { return JSON.parse(localStorage.getItem(PREF_KEY) || '{}'); } catch { return {}; } };
const savePrefs = (p) => localStorage.setItem(PREF_KEY, JSON.stringify(p));

// ----- Custom Measurements helpers/eligibility -----
const isCustomMeasure = (row) => /custom\s*measure/i.test(N(row?.enhancement || row?.subtype || ''));
const isProgN = (label) => /\bprogressive\b.*\bN\b/i.test(N(label));
const isProgO = (label) => /\bprogressive\b.*\bO\b/i.test(N(label));
function cmEligibleForLabel(label){
  const s = N(label);
  return isProgN(s) || isProgO(s);  // potentially eligible; office toggle controls usage
}

/* -------- CSV parsing & cache -------- */
function parseCSV(text){
  const rows=[]; let row=[], field='', q=false;
  for(let i=0;i<text.length;i++){
    const ch=text[i];
    if(ch==='\"'){ if(q && text[i+1]==='\"'){ field+='\"'; i++; } else { q=!q; } continue; }
    if(!q && ch===','){ row.push(field); field=''; continue; }
    if(!q && (ch==='\n' || ch==='\r')){ if(field!==''||row.length){ row.push(field); rows.push(row); row=[]; field=''; } continue; }
    field+=ch;
  }
  if(field!==''||row.length){ row.push(field); rows.push(row); }
  const headers = rows.shift().map(h=>h.replace(/^\"|\"$/g,'').trim());
  return rows.filter(r=>r.length>=headers.length).map(r=>{
    const o={}; headers.forEach((h,i)=>o[h]=(r[i]||'').replace(/^\"|\"$/g,'').trim()); return o;
  });
}

const CACHE_KEY='rev-vsp-choice-csv-v1';
const META_KEY='rev-vsp-choice-meta-v1';
const setCache=(t,m)=>{ localStorage.setItem(CACHE_KEY,t); localStorage.setItem(META_KEY,JSON.stringify(m)); };
const getCache=()=>({ text: localStorage.getItem(CACHE_KEY), meta: JSON.parse(localStorage.getItem(META_KEY)||'{}') });
const clearCacheStorage=()=>{ localStorage.removeItem(CACHE_KEY); localStorage.removeItem(META_KEY); };

let DATA=[];

async function loadCSV(){
  const status=el('status'); status.textContent=' loading…';
  try{
    const res = await fetch(DEFAULT_CSV,{cache:'no-store'});
    if(!res.ok) throw new Error('HTTP '+res.status);
    const text = await res.text();
    const meta = { plan:'VSP_choice', version:new Date().toISOString().slice(0,10)+'.gbb', source:'network:'+DEFAULT_CSV, sha:quickHash(text) };
    setCache(text, meta);
    DATA = parseCSV(text);
    renderMeta(DATA.length, meta);
    status.textContent = ` [ok] loaded ${DATA.length} rows`;
    computeBundles();
  }catch(err){
    const {text, meta} = getCache();
    if(text){
      DATA = parseCSV(text);
      renderMeta(DATA.length, {...meta, source:'cache'});
      el('status').textContent = ` Network failed (${err.message}). Using cached data (${DATA.length} rows).`;
      computeBundles();
    }else{
      el('status').textContent = ' Load failed: '+err.message+' (no cache available)';
    }
  }
}

function renderMeta(count, meta){
  el('version').textContent = `plan=${meta.plan||'VSP_choice'} • rows=${count||0} • version=${meta.version||'—'} • source=${meta.source||'—'} • sha=${meta.sha||'—'}`;
}

/* ---------------- Data selectors & ranking ---------------- */
const byKey=(k)=>DATA.filter(r=>(r.active||'yes').toLowerCase()==='yes' && (r.exclusive_key||'').toLowerCase()===k);

function applies(row, fam){
  const a=(row.applies_to||'ALL').toUpperCase();
  if(a.includes('ALL')) return true;
  if(fam==='SV')     return a.includes('SV');
  if(fam==='LINED')  return a.includes('OCC');
  if(fam==='PAL')    return a.includes('MF');
  return true;
}

const profitOf = (row)=> num(row.copay) - num(row.chargeback);
const pickBest = (arr)=> (arr && arr.length ? [...arr].sort((a,b)=>profitOf(b)-profitOf(a))[0] : null);

function rankAR(ars){
  const gradeVal = (s)=>{
    const m = String(s||'').match(/\b([A-D])\b/i);
    if(!m) return null;
    const g = m[1].toUpperCase();
    return {A:1,B:2,C:3,D:4}[g]||null;
  };
  return [...ars].sort((a,b)=>{
    const ga = gradeVal(a.enhancement)||-1, gb = gradeVal(b.enhancement)||-1;
    if(ga!==gb) return gb-ga;   // D..A
    return profitOf(b)-profitOf(a);
  });
}

function materialKey(label) {
  const s = N(label);
  if(/polycarb/.test(s)) return 'poly';
  if(/trivex/.test(s)) return 'trivex';
  if(/1\.74|1\.75/.test(s)) return 'hi174';
  if(/1\.70|1\.71|above/.test(s)) return 'hi70';
  if(/1\.66|1\.67/.test(s)) return 'hi167';
  if(/cr[- ]?39|plastic(?!.*high)/.test(s)) return 'cr39';
  return 'other';
}
function sunMatchesBase(sunRow, baseRow) {
  const mk = materialKey(baseRow.enhancement || baseRow.subtype || '');
  const t = N(sunRow.enhancement);
  switch (mk) {
    case 'poly':   return /polycarb/.test(t);
    case 'trivex': return /trivex/.test(t);
    case 'hi174':  return /(1\.74|1\.75)/.test(t);
    case 'hi70':   return /(1\.70|1\.71|above)/.test(t);
    case 'hi167':  return /(1\.66|1\.67)/.test(t);
    case 'cr39':   return /(cr[- ]?39|plastic(?!.*high))/.test(t);
    default:       return true;
  }
}

function line(row){
  const cop = num(row.copay), cb=num(row.chargeback), pr=cop-cb;
  return { name: row.enhancement||row.subtype||'—', code: row.code||'', copay:cop, chargeback:cb, profit:pr };
}

function makeBundle(base, addOns){
  const items=[base, ...addOns.filter(Boolean)];
  const lines = items.map(line);
  const cop = sum(lines.map(x=>x.copay));
  const cb  = sum(lines.map(x=>x.chargeback));
  const pr  = cop - cb;
  const ratio = cop>0 ? (pr/cop) : 0; // tie-breaker only
  const label = base.enhancement || base.subtype || base.code || 'Base';
  return { label, lines, copay:cop, chargeback:cb, profit:pr, ratio, baseRow: base };
}

/* ---------------- Presentation helpers ---------------- */
function animateNumber(el,to){
  const from=parseFloat(el.getAttribute('data-prev')||'0'); const start=performance.now(); const dur=380;
  function step(t){ const k=Math.min(1,(t-start)/dur); const v=from+(to-from)*(0.5-Math.cos(Math.PI*k)/2); el.textContent=`$${v.toFixed(2)}`; if(k<1)requestAnimationFrame(step); else el.setAttribute('data-prev',to); }
  requestAnimationFrame(step);
}
function tdMoney(v){ return `<td class="money">$${v.toFixed(2)}</td>`; }

function renderTier({name, cls, b}){
  const div=document.createElement('div'); div.className='tier';
  if(!b){
    div.innerHTML=`<div class="tierHead"><div class="stars ${cls}"><span class="tag">${name}</span></div><div class="figures"><div class="hero">—</div><div class="caption">Patient Copay</div></div></div><div class="sub">No viable bundle</div>`;
    return div;
  }
  const stars = name==='Best' ? '★★★' : name==='Better' ? '★★' : name==='Good' ? '★' : '◎';
  const head = `
    <div class="tierHead">
      <div class="stars ${cls}">
        <div aria-label="${name}" title="${name}" style="font-size:18px">${stars}</div>
        <span class="tag">${b.label}</span>
      </div>
      <div class="figures">
        <div class="hero" aria-label="Patient Copay" data-prev="0">$${b.copay.toFixed(2)}</div>
        <div class="caption">Patient Copay</div>
        <div class="caption">Service Fee (Practice Profit): <span class="svc">$${b.profit.toFixed(2)}</span></div>
      </div>
    </div>`;
  const lines = b.lines.map(li=>`
    <tr>
      <td>${li.name}</td>
      <td class="code">${li.code||'—'}</td>
      ${tdMoney(li.copay)}
      ${tdMoney(li.chargeback)}   <!-- Holdback -->
      ${tdMoney(li.profit)}       <!-- Service Fee per line -->
    </tr>`).join('');
  div.innerHTML = head + `
    <table>
      <thead>
        <tr>
          <th>Item</th>
          <th>Code</th>
          <th class="nowrap">Copay</th>
          <th class="nowrap">Holdback</th>
          <th class="nowrap">Service Fee</th>
        </tr>
      </thead>
      <tbody>${lines}</tbody>
      <tfoot>
        <tr>
          <th colspan="2" style="text-align:right">Totals</th>
          ${tdMoney(b.copay)}${tdMoney(b.chargeback)}${tdMoney(b.profit)}
        </tr>
      </tfoot>
    </table>`;
  const hero = div.querySelector('.hero'); animateNumber(hero, b.copay);
  return div;
}

function renderStack(rows){
  const stack = el('stack');
  stack.innerHTML='';
  for(const row of rows){ stack.appendChild(renderTier(row)); }
}

/* ================== Compute bundles ================== */
function computeBundles(){
  if(!DATA.length){ el('stack').innerHTML=''; return; }

  const fam = el('lensFamily').value;
  const wantAR = el('includeAR').checked;
  const wantAsp = el('includeAspheric').checked;
  const wantOS  = el('includeOversize').checked;
  const wantGlass = el('includeGlass').checked;
  const tintSel = el('lensTint').value; // clear|tinted|polarized|transitions

  // sun tech pool
  const sunAll = byKey('sun_tech').filter(r=>applies(r,fam)).filter(r=>{
    const n=N(r.enhancement);
    if(!wantGlass && n.includes('glass')) return false;
    return true;
  });

  // CM pool (PAL-only feature)
  const customPool = DATA.filter(r => applies(r, 'PAL')).filter(isCustomMeasure);

  // base candidates
  let base = [];
  if (fam === 'PAL') {
    base = byKey('progressive_level').filter(r=>applies(r,fam)).filter(r=>{
      const name=N(r.enhancement);
      if(!wantAsp && name.includes('aspheric')) return false;
      if(!wantGlass && name.includes('glass'))  return false;
      if(isCustomMeasure(r)) return false;       // CM cannot be base
      if (tintSel==='polarized') return /polariz/.test(name);
      return !/(photochrom|polariz|tint|tinted|sunglass|gradient)/.test(name);
    });
  } else {
    if (tintSel==='polarized') {
      base = sunAll.filter(r => /polariz/.test(N(r.enhancement)) && isDCode(r));
    } else {
      const pool = (fam==='SV' ? byKey('base_material') : byKey('occupational'));
      base = pool.filter(r=>applies(r,fam)).filter(r=>{
        const name=N(r.enhancement);
        if(!wantAsp && name.includes('aspheric')) return false;
        if(!wantGlass && name.includes('glass'))  return false;
        if(/photochrom|polariz|tint|tinted|sunglass|gradient/.test(name)) return false;
        return true;
      });
    }
  }

  // AR pool
  const arPool = wantAR ? byKey('ar_level').filter(r=>applies(r,fam)) : [];
  const arRanked = wantAR ? rankAR(arPool) : [];
  const arOptions = wantAR && arRanked.length ? arRanked : [null]; // try all ARs if included

  function chooseSunFor(baseRow) {
    if (tintSel==='clear' || tintSel==='polarized') return null;

    if (tintSel==='transitions') {
      const want = preferPhotoCodeForBase(baseRow);
      let pool = sunAll.filter(r => /photochrom/.test(N(r.enhancement)));
      let choice = pickBest(pool.filter(r => new RegExp('^' + want, 'i').test((r.code || '').trim())));
      if (choice) return choice;
      choice = pickBest(pool.filter(isPPhoto));
      if (choice) return choice;
      return pickBest(pool);
    }

    if (tintSel==='tinted') {
      let pool = sunAll.filter(r=>{
        const n=N(r.enhancement);
        return sunMatchesBase(r, baseRow) && !/photochrom|polariz/.test(n) && /tint|tinted|solid|gradient|sunglass/.test(n);
      });
      return pickBest(pool);
    }

    return null;
  }

  function customFor(baseRow) {
    const cmToggle = el('includeCM')?.checked;
    if (!cmToggle) return null;
    if (fam !== 'PAL') return null;

    const label = baseRow.enhancement || baseRow.subtype || baseRow.code || '';
    if (!cmEligibleForLabel(label)) return null;

    return pickBest(customPool) || null;  // attach once
  }

  // Oversize add-on
  const overs = wantOS ? pickBest(byKey('oversize').filter(r=>applies(r,fam)).filter(r=>{
    const n=N(r.enhancement);
    if(!wantGlass && n.includes('glass')) return false;
    return true;
  })) : null;

  // Build ALL bundles across bases x AR options (with current sun/custom/overs toggles)
  function buildBundle(m, arRow){ return makeBundle(m, [arRow, chooseSunFor(m), customFor(m), overs]); }
  const all = [];
  for(const m of base){
    for(const ar of arOptions){
      all.push(buildBundle(m, ar));
    }
  }
  if (!all.length){ renderStack([{name:'Good',cls:'good',b:null},{name:'Better',cls:'better',b:null},{name:'Best',cls:'best',b:null},{name:'Cheapest',cls:'good',b:null}]); return; }

  // Anchor to MaxPrice among all combos
  const MaxPrice = Math.max(...all.map(b => b.copay));

  // Helpers that respect (optional) base-label exclusions but will retry without excludes if empty
  function mostProfitUnderCap(cap, exclude=new Set()){
    let pick=null, bestProfit=-Infinity;
    for(const b of all){
      if (b.copay <= cap){
        const lbl = b.label;
        if (exclude.has(lbl)) continue;
        if (b.profit>bestProfit || (b.profit===bestProfit && (b.copay<(pick?.copay??Infinity) || b.ratio>(pick?.ratio??-Infinity)))){
          bestProfit=b.profit; pick=b;
        }
      }
    }
    if (pick) return pick;
    // relax excludes once if nothing found
    for(const b of all){
      if (b.copay <= cap){
        if (b.profit>(pick?.profit??-Infinity) || (b.profit===(pick?.profit??-Infinity) && (b.copay<(pick?.copay??Infinity) || b.ratio>(pick?.ratio??-Infinity)))){
          pick=b;
        }
      }
    }
    return pick;
  }
  function cheapest(exclude=new Set()){
    let pick=null;
    for(const b of all){
      const lbl=b.label;
      if (exclude.has(lbl)) continue;
      if (!pick || b.copay<pick.copay || (b.copay===pick.copay && b.profit>(pick.profit))){
        pick=b;
      }
    }
    if (pick) return pick;
    // retry without excludes if needed
    for(const b of all){
      if (!pick || b.copay<pick.copay || (b.copay===pick.copay && b.profit>(pick.profit))){
        pick=b;
      }
    }
    return pick;
  }
  function mostProfit(allBundles){
    let pick=null;
    for(const b of allBundles){
      if (!pick || b.profit>pick.profit || (b.profit===pick.profit && b.ratio>pick.ratio)){
        pick=b;
      }
    }
    return pick;
  }

  // 1) BEST = max profit across all
  const best = mostProfit(all);
  const used = new Set(best ? [best.label] : []);

  // 2) BETTER = most profit under 75% of MaxPrice (relax if needed)
  const capBetter1 = MaxPrice * BETTER_CAP_OF_MAX;
  let better = mostProfitUnderCap(capBetter1, used);
  if (!better && CAP_RELAX_FACTOR !== 1){
    const capBetter2 = MaxPrice * (BETTER_CAP_OF_MAX / CAP_RELAX_FACTOR);
    better = mostProfitUnderCap(capBetter2, used);
  }
  if (better) used.add(better.label);

  // 3) GOOD = most profit under 50% of MaxPrice (relax if needed)
  const capGood1 = MaxPrice * GOOD_CAP_OF_MAX;
  let good = mostProfitUnderCap(capGood1, used);
  if (!good && CAP_RELAX_FACTOR !== 1){
    const capGood2 = MaxPrice * (GOOD_CAP_OF_MAX / CAP_RELAX_FACTOR);
    good = mostProfitUnderCap(capGood2, used);
  }
  if (!good){
    // final fallback so a card always shows
    good = cheapest(used);
  }
  if (good) used.add(good.label);

  // 4) CHEAPEST = absolute lowest copay (ties → higher profit)
  const cheap = cheapest(used);

  renderStack([
    {name:'Good',     cls:'good',    b:good},
    {name:'Better',   cls:'better',  b:better},
    {name:'Best',     cls:'best',    b:best},
    {name:'Cheapest', cls:'good',    b:cheap}
  ]);
}

/* ---------------- Wire-up ---------------- */
el('forceRefresh').onclick=()=>{ clearCacheStorage(); loadCSV(); };
el('clearCache').onclick =()=>{ clearCacheStorage(); el('status').textContent=' cache cleared — click Force Refresh to reload'; };

// Persist includeCM per office, recompute on any change
['lensFamily','lensTint','includeAR','includeAspheric','includeOversize','includeGlass','includeCM']
  .forEach(id => {
    const node = el(id);
    if (!node) return;
    node.onchange = () => {
      if (id === 'includeCM') {
        const p = loadPrefs();
        p.includeCM = node.checked;
        savePrefs(p);
      }
      computeBundles();
    };
  });

// On boot: restore office preference (default OFF), then load CSV
(function boot(){
  const prefs = loadPrefs();
  if (el('includeCM') && typeof prefs.includeCM === 'boolean') {
    el('includeCM').checked = prefs.includeCM;
  }
  loadCSV();
})();
</script>
