<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>RevSight AI — VSP Choice Profit Engine</title>
  <style>
    :root{ --bg:#0b0f14; --panel:#121822; --border:#2a3444; --text:#e7eefc; --muted:#9fb3d2; --good:#1fbf75; --mid:#f6c343; --best:#9867ff; }
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--text);font:16px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",Arial}
    header{padding:18px 16px;border-bottom:1px solid var(--border);display:flex;gap:12px;align-items:center;justify-content:space-between}
    h1{margin:0;font-size:18px}
    .sub{font-size:12px;color:var(--muted)}
    .row{display:flex;gap:12px;flex-wrap:wrap}
    .col{flex:1 1 320px}
    .card{background:var(--panel);border:1px solid var(--border);border-radius:12px;padding:14px}
    label{display:flex;align-items:center;gap:8px;margin:8px 0;font-size:14px;color:var(--muted)}
    input[type="checkbox"]{width:18px;height:18px}
    select,button{background:#0f1520;color:var(--text);border:1px solid var(--border);border-radius:10px;padding:10px 12px;font:inherit}
    button{cursor:pointer}
    .pill{display:inline-flex;align-items:center;gap:8px;padding:6px 10px;border-radius:999px;border:1px solid var(--border);font-size:12px;color:var(--muted)}
    .bundle{border-left:4px solid var(--border);padding-left:10px;margin:6px 0}
    .bundle.good{border-color:var(--good)} .bundle.mid{border-color:var(--mid)} .bundle.best{border-color:var(--best)}
    .muted{color:var(--muted)}
    table{width:100%;border-collapse:collapse;font-size:14px}
    th,td{padding:8px;border-bottom:1px solid var(--border)} th{color:var(--muted);font-weight:600;text-align:left}
    .right{text-align:right}
    .tag{display:inline-block;padding:2px 6px;border-radius:6px;background:#0e1622;border:1px solid var(--border);font-size:12px;margin-right:6px;color:var(--muted)}
  </style>
</head>
<body>
  <header>
    <div>
      <h1>RevSight AI — VSP Choice Profit Engine</h1>
      <div class="sub">
        Profit = <b>sum of VSP service fees</b>. MF bundles stack <b>family base “A”</b> + <b>material add‑on</b> (e.g., OA+OD, KA+KD). Treatments (Polarized / Tinted / Transitions) are selected explicitly and never treated as materials.
      </div>
    </div>
    <div class="row" style="align-items:center">
      <span class="pill" id="csvStatus">CSV: not loaded</span>
      <button id="forceRefresh">Recalc</button>
    </div>
  </header>

  <main class="row" style="padding:16px">
    <section class="col card">
      <h3 style="margin-top:0">Inputs</h3>
      <div class="row">
        <div class="col">
          <label>Lens type
            <select id="lensType">
              <option value="SV">Single Vision (SV)</option>
              <option value="MF">Progressive / Multifocal (MF)</option>
            </select>
          </label>
        </div>
        <div class="col">
          <label>Material preference
            <select id="materialPref">
              <option value="">No preference</option>
              <option value="PLASTIC">Plastic</option>
              <option value="POLYCARBONATE">Polycarbonate</option>
              <option value="HI67">Hi‑Index 1.67</option>
              <option value="HI70">Hi‑Index 1.70</option>
              <option value="TRIVEX">Trivex</option>
              <option value="GLASS">Glass</option>
            </select>
          </label>
        </div>
        <div class="col">
          <label>Lens treatment (exclusive)
            <select id="treatment">
              <option value="CLEAR">Clear</option>
              <option value="POLARIZED">Polarized</option>
              <option value="TINTED">Tinted</option>
              <option value="TRANSITIONS">Transitions / Photochromic</option>
            </select>
          </label>
        </div>
      </div>

      <div class="row" style="margin-top:6px">
        <div class="col">
          <div class="sub" style="margin-bottom:6px">Global Toggles (default states per spec)</div>
          <label><input id="toggleOversize" type="checkbox"> Oversize (default OFF)</label>
          <label><input id="toggleAR" type="checkbox" checked> AR Coating (default ON)</label>
          <label><input id="toggleAspheric" type="checkbox"> Aspheric (default OFF)</label>
          <label><input id="toggleGlass" type="checkbox"> Glass (default OFF)</label>
        </div>
      </div>
      <div class="sub">OFF excludes that category from <i>all</i> bundles.</div>
    </section>

    <section class="col card">
      <h3 style="margin-top:0">Recommended Bundles (by profit)</h3>
      <div id="bundles"></div>
    </section>

    <section class="col card">
      <h3 style="margin-top:0">Line‑item Economics</h3>
      <div id="lineItems"></div>
    </section>
  </main>

  <section class="card" style="margin:16px">
    <details open>
      <summary>Data/Diagnostics</summary>
      <div id="diag" class="muted" style="white-space:pre-wrap"></div>
    </details>
  </section>

<script>
/* ========================= CSV + HELPERS ========================= */
const CSV_URLS = [
  'https://bblaker575.github.io/Revopt-site/vsp_choice_master_v7_full_fixed.csv',
  'https://raw.githubusercontent.com/bblaker575/Revopt-site/main/vsp_choice_master_v7_full_fixed.csv'
];
async function loadCSV(){
  const badge = document.getElementById('csvStatus');
  const tried = [];
  for(const url of CSV_URLS){
    try{
      const resp = await fetch(url + '?t=' + Date.now(), {cache:'no-store'});
      if(!resp.ok) throw new Error(resp.status + ': ' + resp.statusText);
      const text = await (await resp.blob()).text();
      const rows = parseCSV(text);
      badge.textContent = 'CSV: loaded from GitHub Pages';
      badge.style.borderColor = '#6cf';
      return rows;
    }catch(e){ tried.push(url + ' → ' + (e.message||e)); }
  }
  badge.textContent = 'CSV: not loaded';
  badge.style.borderColor = '#f66';
  const diag = document.getElementById('diag');
  if(diag) diag.textContent = 'Tried URLs:
- ' + tried.join('
- ');
  return [];
}
function parseCSV(text){
  const rows=[]; let i=0, cur=''; let inQ=false; let row=[]; const push=()=>{ row.push(cur); cur=''; };
  while(i<text.length){ const c=text[i++]; if(c=='"'){ if(inQ && text[i]=='"'){ cur+='"'; i++; } else inQ=!inQ; }
    else if(c===',' && !inQ){ push(); }
    else if((c==='
'||c==='
') && !inQ){ if(cur!==''||row.length){ push(); rows.push(row); row=[]; } }
    else cur+=c; }
  if(cur!==''||row.length){ push(); rows.push(row); }
  const headers = rows.shift().map(h=>h.trim());
  return rows.filter(r=>r.length && r.some(x=>String(x).trim()!==''))
             .map(r=>{ const o={}; headers.forEach((h,idx)=>o[h]=r[idx]??''); return o; });
}
const uc = s=>String(s||'').toUpperCase();
const num = x=>{ const n=Number(String(x).replace(/[^0-9.\-]/g,'')); return Number.isFinite(n)?n:0; };
const truthy = x=>{ x=String(x||'').trim().toLowerCase(); return x===''||x==='1'||x==='y'||x==='yes'||x==='true'; };
const falsy  = x=>{ x=String(x||'').trim().toLowerCase(); return x==='0'||x==='n'||x==='no'||x==='false'; };
const byProfitDesc=(a,b)=>b.profit-a.profit;
function normalizeMaterial(txt){
  const t=uc(txt);
  if(t.includes('POLY')) return 'POLYCARBONATE';
  if(t.includes('1.70')) return 'HI70';
  if(t.includes('1.66')||t.includes('1.67')) return 'HI67';
  if(t.includes('TRIVEX')) return 'TRIVEX';
  if(t.includes('GLASS')) return 'GLASS';
  if(t.includes('PLASTIC')) return 'PLASTIC';
  return t||'PLASTIC';
}
function detectTreatment(text){
  const t=uc(text);
  if(t.includes('POLAR')) return 'POLARIZED';
  if(t.includes('TINT')) return 'TINTED';
  if(t.includes('PHOTO')||t.includes('TRANSITIONS')||t.includes('TRANSITION')) return 'TRANSITIONS';
  return '';
}

/* ========================= CLASSIFY ========================= */
function computeProfit(row){ return num(row.vsp); }
function classify(row){
  if('active' in row && falsy(row.active)) return null;
  const applies = uc(row.applies_to);
  let lensType = 'BOTH';
  if(applies.includes('MF') && !applies.includes('SV') && !applies.includes('ALL')) lensType='MF';
  else if(applies.includes('SV') && !applies.includes('MF') && !applies.includes('ALL')) lensType='SV';

  const group=uc(row.group||'');
  const code=uc(row.code||'');
  const exkey=uc(row.exclusive_key||'');
  const materialTxt=uc(row.subtype||'');
  const enhancementTxt=uc(row.enhancement||'');
  const desc = row.enhancement || row.subtype || row.code || '';

  const isBaseSV = group.includes('MATERIAL') && (exkey.includes('BASE')||exkey.includes('MATERIAL')||exkey==='');

  const isProgressive = group.includes('PROGRESSIVE');
  let family='', variant='';
  if(isProgressive && code.length>=2){ family=code[0]; variant=code[1]; }
  const isBaseMF = isProgressive && variant==='A';
  const mfMaterial = isProgressive ? normalizeMaterial(enhancementTxt||materialTxt) : '';

  // treatment detection (non-material)
  const treatment = detectTreatment(desc + ' ' + enhancementTxt + ' ' + materialTxt + ' ' + group);

  const t=(materialTxt+' '+enhancementTxt);
  const flags={
    AR: t.includes(' AR')||t.startsWith('AR')||t.includes('ANTI-REFLECT'),
    ASPHERIC: t.includes('ASPHERIC'),
    GLASS: t.includes('GLASS'),
    OVERSIZE: t.includes('OVERSIZE')||t.includes('OVR')||t.includes('61MM'),
    TREATMENT: !!treatment
  };

  return {
    lensType,
    material: isBaseSV ? normalizeMaterial(materialTxt) : (isProgressive ? mfMaterial : ''),
    enhancement: (!isBaseSV && !isProgressive && !flags.TREATMENT) ? enhancementTxt : '',
    treatment,
    desc,
    profit: computeProfit(row),
    raw: row,
    f: flags,
    baseKind: isBaseSV ? 'SV' : (isProgressive ? 'MF' : ''),
    family, variant
  };
}
function buildUniverse(rows){
  const mapped=rows.map(classify).filter(Boolean);
  return mapped.filter(it=> it.baseKind ? true : (!('composable' in it.raw) || truthy(it.raw.composable)));
}
function applyGlobalToggles(items, toggles){
  return items.filter(it=>{
    if(!toggles.AR && (it.enhancement.includes('AR')||it.f.AR)) return false;
    if(!toggles.ASPHERIC && (it.material.includes('ASPHERIC')||it.f.ASPHERIC)) return false;
    if(!toggles.GLASS && (it.material.includes('GLASS')||it.f.GLASS)) return false;
    if(!toggles.OVERSIZE && (it.enhancement.includes('OVERSIZE')||it.f.OVERSIZE)) return false;
    return true;
  });
}

/* ========================= BUNDLING ========================= */
function pickBundles(universe, lensType, materialPref, toggles, treatmentSel){
  const pool=applyGlobalToggles(universe.filter(u=>!lensType || u.lensType===lensType || u.lensType==='BOTH'), toggles);
  const isMF=lensType==='MF';

  // choose one treatment based on dropdown
  const treatmentPick = (treatmentSel && treatmentSel!=='CLEAR') ? treatmentSel : '';
  const treatmentItem = treatmentPick ? pool.filter(x=>!x.baseKind && x.f.TREATMENT && x.treatment===treatmentPick).sort(byProfitDesc)[0] : null;

  if(isMF){
    const basesByFamily={};
    const addOnByFamilyMaterial={};
    for(const x of pool.filter(x=>x.baseKind==='MF')){
      if(x.variant==='A'){ basesByFamily[x.family]=x; }
      else{
        const mat=x.material||'PLASTIC';
        (addOnByFamilyMaterial[x.family] ||= {})[mat]=x;
      }
    }
    const families=Object.keys(basesByFamily);
    const materialsSet=new Set(['PLASTIC','POLYCARBONATE','HI67','HI70','TRIVEX','GLASS']);
    for(const fam of Object.keys(addOnByFamilyMaterial)){
      for(const m of Object.keys(addOnByFamilyMaterial[fam])) materialsSet.add(m);
    }
    const allMaterials=Array.from(materialsSet);
    const candidateMaterials=(materialPref && allMaterials.includes(materialPref))?[materialPref]:allMaterials;

    const enhPool=pool.filter(x=>!x.baseKind && !x.f.TREATMENT);
    const bestAR = toggles.AR ? enhPool.filter(e=>e.f.AR).sort(byProfitDesc)[0] : null;
    const bestOversize = toggles.OVERSIZE ? enhPool.filter(e=>e.f.OVERSIZE).sort(byProfitDesc)[0] : null;

    const bundles=[];
    for(const fam of families){
      const baseA=basesByFamily[fam]; if(!baseA) continue;
      for(const mat of candidateMaterials){
        const parts=[baseA];
        const add=(addOnByFamilyMaterial[fam]||{})[mat];
        if(add && add!==baseA) parts.push(add);
        if(treatmentItem) parts.push(treatmentItem);
        if(bestAR) parts.push(bestAR);
        if(bestOversize) parts.push(bestOversize);
        const seen=new Set(); let profit=0; const lines=[];
        for(const p of parts){ const key=(p.raw.code||'')+'|'+(p.desc||''); if(seen.has(key)) continue; seen.add(key); lines.push(p); profit+=p.profit; }
        bundles.push({ material:mat, family:fam, parts:lines, profit });
      }
    }
    bundles.sort(byProfitDesc);
    const uniq=[]; const seenCombo=new Set();
    for(const b of bundles){ const k=b.family+'|'+b.material; if(!seenCombo.has(k)){ uniq.push(b); seenCombo.add(k);} }
    const best=uniq[0]; const mid=uniq[1]||uniq[0]; const good=uniq[uniq.length-1]||uniq[0];
    return {good,mid,best,poolSize:uniq.length};
  }

  // SV path
  const bases=pool.filter(x=>x.baseKind==='SV');
  const enhPool=pool.filter(x=>!x.baseKind && !x.f.TREATMENT);
  const buckets=bases.reduce((m,x)=>{ const k=x.material||x.desc; (m[k]??=[]).push(x); return m; },{});
  const keys=Object.keys(buckets);
  const candidateKeys=(materialPref && keys.includes(materialPref))?[materialPref]:keys;
  const bestAR = toggles.AR ? enhPool.filter(e=>e.f.AR).sort(byProfitDesc)[0] : null;
  const bestOversize = toggles.OVERSIZE ? enhPool.filter(e=>e.f.OVERSIZE).sort(byProfitDesc)[0] : null;
  const bundles=[];
  for(const k of (candidateKeys.length?candidateKeys:keys)){
    const base=(buckets[k]||[]).sort(byProfitDesc)[0]; if(!base) continue; const parts=[base];
    if(treatmentItem) parts.push(treatmentItem);
    if(bestAR) parts.push(bestAR);
    if(bestOversize) parts.push(bestOversize);
    const seen=new Set(); let profit=0; const lines=[];
    for(const p of parts){ const key=(p.raw.group||'')+'|'+(p.material||'')+'|'+(p.enhancement||'')+'|'+(p.desc||''); if(seen.has(key)) continue; seen.add(key); lines.push(p); profit+=p.profit; }
    bundles.push({ material:k, parts:lines, profit });
  }
  bundles.sort(byProfitDesc);
  const uniq=[]; const seenKey=new Set();
  for(const b of bundles){ if(!seenKey.has(b.material)){ uniq.push(b); seenKey.add(b.material); } }
  const best=uniq[0]; const mid=uniq[1]||uniq[0]; const good=uniq[uniq.length-1]||uniq[0];
  return {good,mid,best,poolSize:uniq.length};
}

/* ========================= RENDER ========================= */
function renderBundles(picks){
  const el=document.getElementById('bundles');
  if(!picks || !picks.best){ el.innerHTML='<div class="muted">No bundles available with current filters.</div>'; return; }
  const make=(b,cls,label)=>{
    if(!b) return `<div class="bundle ${cls}"><div class="muted">No ${label} bundle</div></div>`;
    const rows=b.parts.map(p=>`<tr><td>${p.raw.code?('<b>'+p.raw.code+'</b> – '):''}${p.desc || (p.material||p.enhancement)}</td><td class="right">$${Number(p.profit).toFixed(2)}</td></tr>`).join('');
    return `<div class="bundle ${cls}">
      <div class="row" style="align-items:center;justify-content:space-between">
        <div class="tag">${label}</div>
        <div class="tag">Material: ${b.material||'—'}</div>
        <div class="tag">Bundle Profit: $${Number(b.profit).toFixed(2)}</div>
      </div>
      <table><thead><tr><th>Line Item</th><th class="right">Profit</th></tr></thead><tbody>${rows}</tbody></table>
    </div>`;
  };
  el.innerHTML = make(picks.good,'good','Good') + make(picks.mid,'mid','Mid') + make(picks.best,'best','Best');
}
function renderLineItems(universe, lensType){
  const el=document.getElementById('lineItems');
  const list=universe.filter(u=>!lensType || u.lensType===lensType || u.lensType==='BOTH').sort(byProfitDesc).slice(0,200);
  if(!list.length){ el.innerHTML='<div class="muted">No items.</div>'; return; }
  el.innerHTML=`<table>
    <thead><tr><th>Type</th><th>Family</th><th>Material</th><th>Enhancement</th><th>Code</th><th>Description</th><th class="right">VSP fee (profit)</th></tr></thead>
    <tbody>${list.map(r=>`<tr><td>${r.lensType||'—'}</td><td>${r.family||'—'}</td><td>${r.material||'—'}</td><td>${r.enhancement|| (r.treatment?('TREAT:'+r.treatment):'—')}</td><td>${r.raw.code||'—'}</td><td>${r.desc||''}</td><td class="right">$${Number(r.profit).toFixed(2)}</td></tr>`).join('')}</tbody>
  </table>`;
}

/* ========================= INIT ========================= */
let UNIVERSE=[];
async function recalc(){
  const lensType=document.getElementById('lensType').value;
  const materialPref=document.getElementById('materialPref').value;
  const treatmentSel=document.getElementById('treatment').value;
  const toggles={
    OVERSIZE:document.getElementById('toggleOversize').checked,
    AR:document.getElementById('toggleAR').checked,
    ASPHERIC:document.getElementById('toggleAspheric').checked,
    GLASS:document.getElementById('toggleGlass').checked,
  };
  const picks=pickBundles(UNIVERSE, lensType, materialPref, toggles, treatmentSel);
  renderBundles(picks); renderLineItems(UNIVERSE, lensType);
  document.getElementById('diag').textContent = JSON.stringify({lensType, materialPref, treatment:treatmentSel, toggles, universe:UNIVERSE.length, poolCandidates:picks.poolSize}, null, 2);
}
(async function init(){
  const raw = await loadCSV();
  UNIVERSE = buildUniverse(raw);
  ['forceRefresh','lensType','materialPref','treatment','toggleOversize','toggleAR','toggleAspheric','toggleGlass']
    .forEach(id=>document.getElementById(id).addEventListener('change', recalc));
  recalc();
})();
</script>
</body>
</html>
