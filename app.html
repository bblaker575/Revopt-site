<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>RevSight AI — VSP Choice Profit Engine</title>
  <style>
    :root{ --bg:#0b0f14; --panel:#121822; --border:#2a3444; --text:#e7eefc; --muted:#9fb3d2; --good:#1fbf75; --mid:#f6c343; --best:#9867ff; }
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--text);font:16px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",Arial}
    header{padding:18px 16px;border-bottom:1px solid var(--border);display:flex;gap:12px;align-items:center;justify-content:space-between}
    h1{margin:0;font-size:18px}
    .sub{font-size:12px;color:var(--muted)}
    .row{display:flex;gap:12px;flex-wrap:wrap}
    .col{flex:1 1 320px}
    .card{background:var(--panel);border:1px solid var(--border);border-radius:12px;padding:14px}
    label{display:flex;align-items:center;gap:8px;margin:8px 0;font-size:14px;color:var(--muted)}
    input[type="checkbox"]{width:18px;height:18px}
    select,button{background:#0f1520;color:var(--text);border:1px solid var(--border);border-radius:10px;padding:10px 12px;font:inherit}
    button{cursor:pointer}
    .pill{display:inline-flex;align-items:center;gap:8px;padding:6px 10px;border-radius:999px;border:1px solid var(--border);font-size:12px;color:var(--muted)}
    .bundle{border-left:4px solid var(--border);padding-left:10px;margin:6px 0}
    .bundle.good{border-color:var(--good)} .bundle.mid{border-color:var(--mid)} .bundle.best{border-color:var(--best)}
    .muted{color:var(--muted)}
    table{width:100%;border-collapse:collapse;font-size:14px}
    th,td{padding:8px;border-bottom:1px solid var(--border)} th{color:var(--muted);font-weight:600;text-align:left}
    .right{text-align:right}
    .tag{display:inline-block;padding:2px 6px;border-radius:6px;background:#0e1622;border:1px solid var(--border);font-size:12px;margin-right:6px;color:var(--muted)}
  </style>
</head>
<body>
  <header>
    <div>
      <h1>RevSight AI — VSP Choice Profit Engine</h1>
      <div class="sub">
        Profit = <b>sum of VSP service fees</b>. SV, Lined (DA), and MF flows separated.
        Treatments (Polarized / Tinted / Transitions) are explicit and never treated as materials.
      </div>
    </div>
    <div class="row" style="align-items:center">
      <span class="pill" id="csvStatus">CSV: not loaded</span>
      <button id="forceRefresh">Recalc</button>
    </div>
  </header>

  <main class="row" style="padding:16px">
    <section class="col card">
      <h3 style="margin-top:0">Inputs</h3>
      <div class="row">
        <div class="col">
          <label>Lens type
            <select id="lensType">
              <option value="SV">Single Vision (SV)</option>
              <option value="LINED">Lined Bi/Tri (Bifocal)</option>
              <option value="MF">Progressive / Multifocal (MF)</option>
            </select>
          </label>
        </div>
        <div class="col">
          <label>Material preference
            <select id="materialPref">
              <option value="">No preference</option>
              <option value="PLASTIC">Plastic</option>
              <option value="POLYCARBONATE">Polycarbonate</option>
              <option value="HI67">Hi-Index 1.67</option>
              <option value="HI70">Hi-Index 1.70</option>
              <option value="TRIVEX">Trivex</option>
              <option value="GLASS">Glass</option>
            </select>
          </label>
        </div>
        <div class="col">
          <label>Lens treatment (exclusive)
            <select id="treatment">
              <option value="CLEAR">Clear</option>
              <option value="POLARIZED">Polarized</option>
              <option value="TINTED">Tinted</option>
              <option value="TRANSITIONS">Transitions / Photochromic</option>
            </select>
          </label>
        </div>
      </div>

      <div class="row" style="margin-top:6px">
        <div class="col">
          <div class="sub" style="margin-bottom:6px">Global Toggles</div>
          <label><input id="toggleOversize" type="checkbox"> Oversize (default OFF)</label>
          <label><input id="toggleAR" type="checkbox" checked> AR Coating (default ON)</label>
          <label><input id="toggleAspheric" type="checkbox"> Aspheric (default OFF)</label>
          <label><input id="toggleGlass" type="checkbox"> Glass (default OFF)</label>
        </div>
      </div>
    </section>

    <section class="col card">
      <h3 style="margin-top:0">Recommended Bundles (by profit)</h3>
      <div id="bundles"></div>
    </section>

    <section class="col card">
      <h3 style="margin-top:0">Line-item Economics</h3>
      <div id="lineItems"></div>
    </section>
  </main>

  <section class="card" style="margin:16px">
    <details open>
      <summary>Data/Diagnostics</summary>
      <div id="diag" class="muted" style="white-space:pre-wrap"></div>
    </details>
  </section>

<script>
/* ========================= CSV (raw GitHub URL) ========================= */
const CSV_URL = 'https://raw.githubusercontent.com/bblaker575/Revopt-site/main/vsp_choice_master_v7_full_fixed.csv';

async function loadCSV(){
  const badge = document.getElementById('csvStatus');
  try{
    const resp = await fetch(CSV_URL + '?t=' + Date.now(), {cache:'no-store'});
    if(!resp.ok) throw new Error(resp.status + ': ' + resp.statusText);
    const text = await resp.text();              // raw.githubusercontent serves plain text
    const rows = parseCSV(text);
    badge.textContent = 'CSV: loaded';
    badge.style.borderColor = '#6cf';
    return rows;
  }catch(e){
    badge.textContent = 'CSV: not loaded';
    badge.style.borderColor = '#f66';
    const diag = document.getElementById('diag');
    if (diag) diag.textContent = 'Error loading CSV: ' + (e.message || e);
    return [];
  }
}

/* ========================= HELPERS ========================= */
function parseCSV(text){
  const rows=[]; let i=0, cur=''; let inQ=false; let row=[];
  const push=()=>{ row.push(cur); cur=''; };
  while(i<text.length){
    const c=text[i++];
    if(c === '"'){ if(inQ && text[i] === '"'){ cur+='"'; i++; } else inQ = !inQ; }
    else if(c === ',' && !inQ){ push(); }
    else if((c === '\n' || c === '\r') && !inQ){ if(cur!=='' || row.length){ push(); rows.push(row); row=[]; } }
    else { cur += c; }
  }
  if(cur!=='' || row.length){ push(); rows.push(row); }
  const headers = rows.shift().map(h=>h.trim());
  return rows
    .filter(r=>r.length && r.some(x=>String(x).trim()!==''))
    .map(r=>{ const o={}; headers.forEach((h,idx)=>o[h] = r[idx] ?? '';); return o; });
}
const uc = s=>String(s||'').toUpperCase();
const num = x=>{ const n=Number(String(x).replace(/[^0-9.\-]/g,'')); return Number.isFinite(n)?n:0; };
const truthy = x=>{ x=String(x||'').trim().toLowerCase(); return x===''||x==='1'||x==='y'||x==='yes'||x==='true'; };
const falsy  = x=>{ x=String(x||'').trim().toLowerCase(); return x==='0'||x==='n'||x==='no'||x==='false'; };
const byProfitDesc=(a,b)=>b.profit-a.profit;

function normalizeMaterial(txt){
  const t=uc(txt);
  if(t.includes('POLY')) return 'POLYCARBONATE';
  if(t.includes('1.70')) return 'HI70';
  if(t.includes('1.66')||t.includes('1.67')) return 'HI67';
  if(t.includes('TRIVEX')) return 'TRIVEX';
  if(t.includes('GLASS')) return 'GLASS';
  if(t.includes('PLASTIC')) return 'PLASTIC';
  return t || 'PLASTIC';
}
function detectTreatment(text){
  const t=uc(text);
  if(t.includes('POLAR')) return 'POLARIZED';
  if(t.includes('TINT')) return 'TINTED';
  if(t.includes('PHOTO')||t.includes('TRANSITIONS')||t.includes('TRANSITION')) return 'TRANSITIONS';
  return '';
}

/* ========================= CLASSIFY ========================= */
function computeProfit(row){ return num(row.vsp); }
function classify(row){
  if('active' in row && falsy(row.active)) return null;

  const applies = uc(row.applies_to||'');
  let lensType = 'BOTH';
  if(applies.includes('MF') && !applies.includes('SV') && !applies.includes('ALL')) lensType='MF';
  else if(applies.includes('SV') && !applies.includes('MF') && !applies.includes('ALL')) lensType='SV';

  const group=uc(row.group||'');
  const code=uc(row.code||'');
  const exkey=uc(row.exclusive_key||'');
  const subtype=uc(row.subtype||'');
  const enhancement=uc(row.enhancement||'');
  const desc = row.enhancement || row.subtype || row.code || '';

  const isProgressive = group.includes('PROGRESSIVE') && !code.startsWith('D');
  const isLined = group.includes('BIFOCAL') || code.startsWith('D');
  const isBaseSV = group.includes('MATERIAL') && (exkey.includes('BASE')||exkey.includes('MATERIAL')||exkey==='');

  let family='', variant='';
  if(isProgressive && code.length>=2){ family=code[0]; variant=code[1]; }
  const mfMaterial = isProgressive ? normalizeMaterial(enhancement||subtype) : '';

  const treatment = detectTreatment(desc + ' ' + enhancement + ' ' + subtype + ' ' + group);
  const t=(subtype+' '+enhancement);
  const flags={
    AR: t.includes(' AR')||t.startsWith('AR')||t.includes('ANTI-REFLECT'),
    ASPHERIC: t.includes('ASPHERIC'),
    GLASS: t.includes('GLASS'),
    OVERSIZE: t.includes('OVERSIZE')||t.includes('OVR')||t.includes('61MM'),
    TREATMENT: !!treatment
  };
  if(isLined) lensType = 'LINED';

  return {
    lensType,
    material: isBaseSV ? normalizeMaterial(subtype) : (isProgressive ? mfMaterial : ''),
    enhancement: (!isBaseSV && !isProgressive && !flags.TREATMENT) ? enhancement : '',
    treatment,
    desc,
    profit: computeProfit(row),
    raw: row,
    f: flags,
    baseKind: isBaseSV ? 'SV' : (isProgressive ? 'MF' : ''),
    family, variant
  };
}
function buildUniverse(rows){
  const mapped=rows.map(classify).filter(Boolean);
  return mapped.filter(it=> it.baseKind ? true : (!('composable' in it.raw) || truthy(it.raw.composable)));
}
function applyGlobalToggles(items, toggles){
  return items.filter(it=>{
    if(!toggles.AR && (it.enhancement.includes('AR')||it.f.AR)) return false;
    if(!toggles.ASPHERIC && (it.material.includes('ASPHERIC')||it.f.ASPHERIC)) return false;
    if(!toggles.GLASS && (it.material.includes('GLASS')||it.f.GLASS)) return false;
    if(!toggles.OVERSIZE && (it.enhancement.includes('OVERSIZE')||it.f.OVERSIZE)) return false;
    return true;
  });
}

/* ========================= BUNDLING ========================= */
function pickBundles(universe, lensType, materialPref, toggles, treatmentSel){
  const pool=applyGlobalToggles(universe.filter(u=>!lensType || u.lensType===lensType || u.lensType==='BOTH'), toggles);
  const isMF=lensType==='MF';
  const isLINED=lensType==='LINED';

  // optional single treatment
  const treatmentPick = (treatmentSel && treatmentSel!=='CLEAR') ? treatmentSel : '';
  const treatmentItem = treatmentPick ? pool.filter(x=>!x.baseKind && x.f.TREATMENT && x.treatment===treatmentPick).sort(byProfitDesc)[0] : null;

  // LINED (D family; DA base + material add-ons)
  if(isLINED){
    const basesByFamily={};
    const addByMat={};
    for(const x of pool.filter(x=>x.raw.code && x.raw.code.startsWith('D'))){
      if(x.variant==='A'){ basesByFamily['D']=x; }
      else{ const m=x.material||'PLASTIC'; (addByMat['D'] ||= {})[m]=x; }
    }
    const baseA=basesByFamily['D'];
    if(baseA){
      const mats=new Set(['PLASTIC','POLYCARBONATE','HI67','HI70','TRIVEX','GLASS']);
      for(const m of Object.keys(addByMat['D']||{})) mats.add(m);
      const cand=(materialPref && mats.has(materialPref))?[materialPref]:Array.from(mats);

      const enh=pool.filter(x=>!x.baseKind && !x.f.TREATMENT);
      const bestAR = toggles.AR ? enh.filter(e=>e.f.AR).sort(byProfitDesc)[0] : null;
      const bestOver = toggles.OVERSIZE ? enh.filter(e=>e.f.OVERSIZE).sort(byProfitDesc)[0] : null;

      const bundles=[];
      for(const m of cand){
        const parts=[baseA];
        const add=(addByMat['D']||{})[m];
        if(add && add!==baseA) parts.push(add);
        if(treatmentItem) parts.push(treatmentItem);
        if(bestAR) parts.push(bestAR);
        if(bestOver) parts.push(bestOver);
        const seen=new Set(); let profit=0; const lines=[];
        for(const p of parts){ const k=(p.raw.code||'')+'|'+(p.desc||''); if(seen.has(k)) continue; seen.add(k); lines.push(p); profit+=p.profit; }
        bundles.push({material:m, family:'D', parts:lines, profit});
      }
      bundles.sort(byProfitDesc);
      const best=bundles[0]; const mid=bundles[1]||best; const good=bundles[bundles.length-1]||best;
      return {good,mid,best,poolSize:bundles.length};
    }
  }

  // MF (family base A + material add-on)
  if(isMF){
    const baseByFam={}, addByFamMat={};
    for(const x of pool.filter(x=>x.baseKind==='MF')){
      if(x.variant==='A'){ baseByFam[x.family]=x; }
      else{ const m=x.material||'PLASTIC'; (addByFamMat[x.family] ||= {})[m]=x; }
    }
    const fams=Object.keys(baseByFam);
    const mats=new Set(['PLASTIC','POLYCARBONATE','HI67','HI70','TRIVEX','GLASS']);
    for(const f of Object.keys(addByFamMat)) for(const m of Object.keys(addByFamMat[f])) mats.add(m);
    const cand=(materialPref && mats.has(materialPref))?[materialPref]:Array.from(mats);

    const enh=pool.filter(x=>!x.baseKind && !x.f.TREATMENT);
    const bestAR = toggles.AR ? enh.filter(e=>e.f.AR).sort(byProfitDesc)[0] : null;
    const bestOver = toggles.OVERSIZE ? enh.filter(e=>e.f.OVERSIZE).sort(byProfitDesc)[0] : null;

    const bundles=[];
    for(const f of fams){
      const baseA=baseByFam[f]; if(!baseA) continue;
      for(const m of cand){
        const parts=[baseA];
        const add=(addByFamMat[f]||{})[m];
        if(add && add!==baseA) parts.push(add);
        if(treatmentItem) parts.push(treatmentItem);
        if(bestAR) parts.push(bestAR);
        if(bestOver) parts.push(bestOver);
        const seen=new Set(); let profit=0; const lines=[];
        for(const p of parts){ const k=(p.raw.code||'')+'|'+(p.desc||''); if(seen.has(k)) continue; seen.add(k); lines.push(p); profit+=p.profit; }
        bundles.push({material:m, family:f, parts:lines, profit});
      }
    }
    bundles.sort(byProfitDesc);
    const uniq=[], seenCombo=new Set();
    for(const b of bundles){ const k=b.family+'|'+b.material; if(!seenCombo.has(k)){ uniq.push(b); seenCombo.add(k);} }
    const best=uniq[0]; const mid=uniq[1]||uniq[0]; const good=uniq[uniq.length-1]||uniq[0];
    return {good,mid,best,poolSize:uniq.length};
  }

  // SV (pick best base by material + allowed enh + optional treatment)
  const bases=pool.filter(x=>x.baseKind==='SV');
  const enh=pool.filter(x=>!x.baseKind && !x.f.TREATMENT);
  const buckets=bases.reduce((m,x)=>{ const k=x.material||x.desc; (m[k]??=[]).push(x); return m; },{});
  const keys=Object.keys(buckets);
  const cand=(materialPref && keys.includes(materialPref))?[materialPref]:keys;
  const bestAR = toggles.AR ? enh.filter(e=>e.f.AR).sort(byProfitDesc)[0] : null;
  const bestOver = toggles.OVERSIZE ? enh.filter(e=>e.f.OVERSIZE).sort(byProfitDesc)[0] : null;

  const bundles=[];
  for(const k of (cand.length?cand:keys)){
    const base=(buckets[k]||[]).sort(byProfitDesc)[0]; if(!base) continue;
    const parts=[base];
    if(treatmentItem) parts.push(treatmentItem);
    if(bestAR) parts.push(bestAR);
    if(bestOver) parts.push(bestOver);
    const seen=new Set(); let profit=0; const lines=[];
    for(const p of parts){ const key=(p.raw.group||'')+'|'+(p.material||'')+'|'+(p.enhancement||'')+'|'+(p.desc||''); if(seen.has(key)) continue; seen.add(key); lines.push(p); profit+=p.profit; }
    bundles.push({ material:k, parts:lines, profit });
  }
  bundles.sort(byProfitDesc);
  const uniq=[], seenKey=new Set();
  for(const b of bundles){ if(!seenKey.has(b.material)){ uniq.push(b); seenKey.add(b.material); } }
  const best=uniq[0]; const mid=uniq[1]||uniq[0]; const good=uniq[uniq.length-1]||uniq[0];
  return {good,mid,best,poolSize:uniq.length};
}

/* ========================= RENDER ========================= */
function renderBundles(picks){
  const el=document.getElementById('bundles');
  if(!picks || !picks.best){ el.innerHTML='<div class="muted">No bundles available with current filters.</div>'; return; }
  const make=(b,cls,label)=>{
    if(!b) return `<div class="bundle ${cls}"><div class="muted">No ${label} bundle</div></div>`;
    const rows=b.parts.map(p=>`<tr><td>${p.raw.code?('<b>'+p.raw.code+'</b> – '):''}${p.desc || (p.material||p.enhancement)}</td><td class="right">$${Number(p.profit).toFixed(2)}</td></tr>`).join('');
    return `<div class="bundle ${cls}">
      <div class="row" style="align-items:center;justify-content:space-between">
        <div class="tag">${label}</div>
        <div class="tag">Material: ${b.material||'—'}</div>
        <div class="tag">Bundle Profit: $${Number(b.profit).toFixed(2)}</div>
      </div>
      <table><thead><tr><th>Line Item</th><th class="right">Profit</th></tr></thead><tbody>${rows}</tbody></table>
    </div>`;
  };
  el.innerHTML = make(picks.good,'good','Good') + make(picks.mid,'mid','Mid') + make(picks.best,'best','Best');
}
function renderLineItems(universe, lensType){
  const el=document.getElementById('lineItems');
  const list=universe.filter(u=>!lensType || u.lensType===lensType || u.lensType==='BOTH').sort(byProfitDesc).slice(0,200);
  if(!list.length){ el.innerHTML='<div class="muted">No items.</div>'; return; }
  el.innerHTML=`<table>
    <thead><tr><th>Type</th><th>Family</th><th>Material</th><th>Treatment</th><th>Enhancement</th><th>Code</th><th>Description</th><th class="right">VSP fee (profit)</th></tr></thead>
    <tbody>${list.map(r=>`<tr><td>${r.lensType||'—'}</td><td>${r.family||'—'}</td><td>${r.material||'—'}</td><td>${r.treatment||'—'}</td><td>${r.enhancement||'—'}</td><td>${r.raw.code||'—'}</td><td>${r.desc||''}</td><td class="right">$${Number(r.profit).toFixed(2)}</td></tr>`).join('')}</tbody>
  </table>`;
}

/* ========================= INIT ========================= */
let UNIVERSE=[];
async function recalc(){
  const lensType=document.getElementById('lensType').value;
  const materialPref=document.getElementById('materialPref').value;
  const treatmentSel=document.getElementById('treatment').value;
  const toggles={
    OVERSIZE:document.getElementById('toggleOversize').checked,
    AR:document.getElementById('toggleAR').checked,
    ASPHERIC:document.getElementById('toggleAspheric').checked,
    GLASS:document.getElementById('toggleGlass').checked,
  };
  const picks=pickBundles(UNIVERSE, lensType, materialPref, toggles, treatmentSel);
  renderBundles(picks); renderLineItems(UNIVERSE, lensType);
  document.getElementById('diag').textContent = JSON.stringify({lensType, materialPref, treatment:treatmentSel, toggles, universe:UNIVERSE.length, poolCandidates:picks.poolSize}, null, 2);
}
(async function init(){
  const raw = await loadCSV();
  UNIVERSE = buildUniverse(raw);
  ['forceRefresh','lensType','materialPref','treatment','toggleOversize','toggleAR','toggleAspheric','toggleGlass']
    .forEach(id=>document.getElementById(id).addEventListener('change', recalc));
  recalc();
})();
</script>
</body>
</html>
