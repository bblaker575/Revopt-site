/* ===== Revopt v6 PRO – logic fixes (drop-in script) ===== */

/* Shorthand + utils */
const $ = (q) => document.querySelector(q);
const num = (n) =>
  Number(n || 0).toLocaleString("en-US", { style: "currency", currency: "USD" });
const clean = (s) => (s == null ? "" : String(s).replace(/^nan$/i, "").trim());

/* Render MASTER (unchanged) */
function renderMaster() {
  const tb = $("#master");
  if (!tb) return;
  tb.innerHTML = "";
  MASTER.forEach((r) => {
    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td>${clean(r.Category)}</td>
      <td>${clean(r.Enhancement)}</td>
      <td>${clean(r.Code)}</td>
      <td>${clean(r.Notes)}</td>
      <td style="text-align:right">${num(r.Copay)}</td>
      <td style="text-align:right">${num(r.VSP)}</td>
      <td style="text-align:right">${num(r.Chargeback)}</td>`;
    tb.appendChild(tr);
  });
}
renderMaster();

/* Helpers to search MASTER */
const where = (fn) => MASTER.filter(fn);
const byEnhRx = (rx) => where((r) => rx.test(r.Enhancement || ""));
const byCatRx = (rx) => where((r) => rx.test(r.Category || ""));
const maxBy = (arr, k) => arr.reduce((a, b) => (+b[k] > +a[k] ? b : a), arr[0]);
const minBy = (arr, k) => arr.reduce((a, b) => (+b[k] < +a[k] ? b : a), arr[0]);

/* ---------- AR picker (A..E ranked) ---------- */
function pickAR(level) {
  let choices = where(
    (r) =>
      /Coating/i.test(r.Category || "") ||
      /anti[- ]?reflect|coating\s*[A-E]\b|\bAR\b/i.test(r.Enhancement || "")
  );
  if (!choices.length) return null;

  const rank = (e) => {
    e = (e || "").toUpperCase();
    if (/\bE\b/.test(e)) return 5;
    if (/\bD\b/.test(e)) return 4;
    if (/\bC\b/.test(e)) return 3;
    if (/\bB\b/.test(e)) return 2;
    if (/\bA\b/.test(e)) return 1;
    return 0;
  };

  choices.sort(
    (x, y) => rank(y.Enhancement) - rank(x.Enhancement) || y.Copay - x.Copay
  );

  if (level === "BEST") return choices[0];
  if (level === "BASIC") return choices[choices.length - 1];
  return choices[Math.max(0, Math.floor(choices.length / 2) - 1)];
}

/* ---------- Material picker (SV/Occ only) ---------- */
function pickMaterial(level) {
  // BASIC → Poly; MID → 1.53–1.60/Trivex; BEST → 1.70+ (fallback 1.66/1.67)
  if (level === "BASIC") {
    const poly = byEnhRx(/polycarbonate/i);
    if (poly.length) return maxBy(poly, "Copay");
  }

  if (level === "MID") {
    const mid = byEnhRx(/high[- ]?index\s*plastic\s*1\.5[3-9]|trivex/i);
    if (mid.length) return maxBy(mid, "Copay");
  }

  // BEST path: try 1.70+, else 1.66/1.67, else best of mid, else poly
  let best = byEnhRx(/high[- ]?index\s*plastic\s*1\.70/i);
  if (best.length) return maxBy(best, "Copay");

  best = byEnhRx(/high[- ]?index\s*plastic\s*1\.6[6-7]/i);
  if (best.length) return maxBy(best, "Copay");

  const mid = byEnhRx(/high[- ]?index\s*plastic\s*1\.5[3-9]|trivex/i);
  if (mid.length) return maxBy(mid, "Copay");

  const poly = byEnhRx(/polycarbonate/i);
  if (poly.length) return maxBy(poly, "Copay");

  // Fallback: plain 1.50/aspheric
  const cr = byEnhRx(/CR-?39|aspheric\s*plastic\s*1\.50|plastic\s*1\.50/i);
  if (cr.length) return minBy(cr, "Copay");

  // Last resort: any Material row
  const any = byCatRx(/material/i);
  return any[0] || null;
}

/* ---------- Progressive picker (chooses ONE – no duplicate materials) ---------- */
function pickProgressive(level) {
  // Map tier → family preference (higher tiers bias to N/O families)
  const families =
    level === "BEST" ? ["N", "O", "F"] : level === "MID" ? ["O", "F", "J"] : ["K", "J", "F"];

  // Map tier → material phrase to pair inside the progressive description
  const materialPhrase =
    level === "BEST"
      ? /(1\.70\s*and\s*Above|1\.66|1\.67)/i
      : level === "MID"
      ? /(1\.53–?1\.60|Trivex)/i
      : /Polycarbonate/i;

  // Gather progressives then filter by family + material phrase
  const progs = where(
    (r) => /progressive/i.test(r.Category || "") || /progressive/i.test(r.Enhancement || "")
  );

  // Try each family in order until we get a match with the target material phrase
  for (const fam of families) {
    const famRows = progs.filter((r) => new RegExp(`Progressive\\s+${fam}\\b`, "i").test(r.Enhancement || ""));
    const famWithMat = famRows.filter((r) => materialPhrase.test(r.Enhancement || ""));
    if (famWithMat.length) return maxBy(famWithMat, "Copay");
    if (famRows.length) return maxBy(famRows, "Copay"); // fallback within family
  }

  // Global fallback: most expensive progressive
  return progs.length ? maxBy(progs, "Copay") : null;
}

/* ---------- Sun add-ons (optional only) ---------- */
function pickSun(path) {
  if (!path || path === "Clear") return null; // default off
  if (path === "Photochromic") {
    const p = byEnhRx(/photochrom|transitions/i).filter((r) => !/glass/i.test(r.Enhancement || ""));
    return p[0] || null;
  }
  if (path === "Polarized") return byEnhRx(/polar/i)[0] || null;
  if (path === "Tint") return byEnhRx(/\b(tint|dyes?)\b/i)[0] || null;
  return null;
}

/* ---------- Deduper + totals ---------- */
function dedupe(items) {
  const seen = new Set();
  return items.filter((i) => {
    if (!i) return false;
    const key = (i.Category || "") + "|" + (i.Enhancement || "");
    if (seen.has(key)) return false;
    seen.add(key);
    return true;
  });
}

function totals(items) {
  const c = items.reduce((s, r) => s + Number(r.Copay || 0), 0);
  const v = items.reduce((s, r) => s + Number(r.VSP || 0), 0);
  const cb = items.reduce((s, r) => s + Number(r.Chargeback || 0), 0);
  return { copay: c, vsp: v, cb: cb, revenue: c + v - cb };
}

/* ---------- Build a single tier list ---------- */
function buildTier(track, sun, level) {
  let items = [];

  if (track === "Progressive") {
    // Pick ONE progressive (already includes its material flavor)
    items.push(pickProgressive(level));
  } else {
    // SV or Occupational → choose Material explicitly
    items.push(pickMaterial(level));
  }

  // AR for all tiers
  items.push(pickAR(level));

  // Sun add-on only if requested (default Clear adds nothing)
  const sitem = pickSun(sun);
  if (sitem) items.push(sitem);

  return dedupe(items);
}

/* ---------- UI handlers ---------- */
document.getElementById("build").addEventListener("click", () => {
  const t = $("#track").value;
  const s = $("#sun").value;
  const over = $("#over").value;
  const rim = $("#rim").value;

  const tiers = [
    { name: "BEST", items: buildTier(t, s, "BEST") },
    { name: "MID", items: buildTier(t, s, "MID") },
    { name: "BASIC", items: buildTier(t, s, "BASIC") }
  ];

  // Optional adders
  if (over !== "None") {
    const os = MASTER.find((r) => /oversize/i.test(r.Enhancement || ""));
    if (os) tiers.forEach((tt) => tt.items.push(os));
  }
  if (rim === "Drill") {
    const rl = MASTER.find((r) => /rimless|drill/i.test(r.Enhancement || ""));
    if (rl) tiers.forEach((tt) => tt.items.push(rl));
  }

  $("#tiers").style.display = "block";

  // Table
  const tb = $("#tierbody");
  tb.innerHTML = "";

  // KPI badges
  const k = $("#kpis");
  k.innerHTML = "";

  tiers.forEach((tt) => {
    const x = totals(tt.items);
    const list = tt.items.map((i) => clean(i.Enhancement)).join(", ");
    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td><b>${tt.name}</b></td>
      <td>${list}</td>
      <td style="text-align:right">${num(x.copay)}</td>
      <td style="text-align:right">${num(x.vsp)}</td>
      <td style="text-align:right">${num(x.cb)}</td>
      <td style="text-align:right"><b>${num(x.revenue)}</b></td>`;
    tb.appendChild(tr);

    const div = document.createElement("span");
    div.className = "kpi";
    div.innerHTML = `<small>${tt.name} revenue</small> <b>${num(x.revenue)}</b>`;
    k.appendChild(div);
  });
});

/* ---------- CSV export (unchanged except single-progressive fix carries through) ---------- */
document.getElementById("csv").addEventListener("click", () => {
  const t = $("#track").value;
  const s = $("#sun").value;
  const tiers = [
    { name: "BEST", items: buildTier(t, s, "BEST") },
    { name: "MID", items: buildTier(t, s, "MID") },
    { name: "BASIC", items: buildTier(t, s, "BASIC") }
  ];

  const rows = [["Tier", "Category", "Enhancement", "Code", "Copay", "VSP", "Chargeback"]];
  tiers.forEach((tt) =>
    tt.items.forEach((i) =>
      rows.push([
        tt.name,
        clean(i.Category),
        clean(i.Enhancement),
        clean(i.Code),
        i.Copay || 0,
        i.VSP || 0,
        i.Chargeback || 0
      ])
    )
  );

  const csv = rows.map((r) => r.map((x) => `"${(x ?? "").toString().replace(/"/g, '""')}"`).join(",")).join("\n");
  const a = document.createElement("a");
  a.href = URL.createObjectURL(new Blob([csv], { type: "text/csv" }));
  a.download = "revopt_quote.csv";
  a.click();
});
