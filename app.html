<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>PayerEdge — VSP Bundles (App v17.4)</title>

  <!-- Typography -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">

  <style>
    :root{
      --bg:#090e16; --bg-elev:#0c1320; --fg:#eaf1ff; --muted:#9fb0c9; --line:#263448;
      --accent:#72a8ff; --accent-2:#7be0c3;
      --tier-best:#ffd166; --tier-better:#a9c2ff; --tier-good:#7be0c3;
      --shadow-lg:0 18px 40px rgba(0,0,0,.35); --shadow-md:0 10px 26px rgba(0,0,0,.28);
      --radius:18px; --radius-sm:12px;
      --fz-12:12px; --fz-13:13px; --fz-15:15px; --fz-18:18px; --fz-20:20px; --fz-36:36px;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      background:
        radial-gradient(1200px 600px at 20% -10%, rgba(90,168,255,.12), transparent 60%),
        radial-gradient(900px 500px at 110% 10%, rgba(123,224,195,.10), transparent 60%),
        var(--bg);
      color:var(--fg);
      font:var(--fz-15)/1.45 Inter, system-ui, -apple-system, "Segoe UI", Roboto, sans-serif;
      -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale;
      font-variant-numeric: tabular-nums;
    }

    header{
      position:sticky; top:0; z-index:20; display:flex; justify-content:space-between; align-items:center; gap:14px;
      padding:16px 20px; background:linear-gradient(180deg, rgba(9,14,22,.95), rgba(9,14,22,.78));
      border-bottom:1px solid var(--line); backdrop-filter: blur(10px);
    }
    h1{margin:0; font-weight:800; font-size:var(--fz-20); letter-spacing:.2px}
    .sub{color:var(--muted); font-size:var(--fz-12)}
    .version{color:var(--muted)}
    main{padding:18px}

    .bar{
      display:flex; align-items:center; flex-wrap:wrap; gap:10px 14px;
      background:linear-gradient(180deg, var(--bg-elev), #0b1220);
      border:1px solid var(--line); border-radius:var(--radius); padding:12px 12px;
      box-shadow: var(--shadow-md);
    }
    .group{display:flex; gap:10px; align-items:center; padding:6px 10px; border-radius:999px; background:#0b1424}
    .btn{ background:#121f35; border:1px solid var(--line); color:var(--fg); padding:8px 12px; border-radius:var(--radius-sm); cursor:pointer; font-weight:600; transition:.15s }
    .btn:hover{ background:#162844; border-color:#2e4260 }
    .switch{display:inline-flex; align-items:center; gap:8px}
    .switch select, .switch input[type="checkbox"]{ accent-color:var(--accent) }
    select{ background:#0e1a30; color:#fff; border:1px solid var(--line); border-radius:10px; padding:6px 8px; outline:none }
    select:focus{ box-shadow:0 0 0 3px rgba(114,168,255,.25) }
    #status{ margin-left:auto; padding:6px 10px; border-radius:999px; border:1px dashed var(--line); background:#0b1422; color:#c7d6ef }

    .stack{ display:grid; gap:18px; grid-template-columns:repeat(auto-fit, minmax(320px,1fr)); align-items:stretch; margin-top:16px }
    .tier{ background:linear-gradient(180deg, #0f1726, #0c1422); border:1px solid var(--line); border-radius:var(--radius); box-shadow: var(--shadow-lg); padding:16px; transition:.25s }
    .tierHead{display:grid; grid-template-columns:1fr auto; align-items:center; gap:10px; margin-bottom:12px}
    .stars{font-weight:800; display:flex; align-items:center; gap:8px}
    .stars .tag{font-size:var(--fz-12); color:var(--muted); padding:2px 8px; border:1px solid var(--line); border-radius:999px; background:#0c1424}
    .stars.best{color:var(--tier-best)} .stars.better{color:var(--tier-better)} .stars.good{color:var(--tier-good)}

    .figures{ text-align:right; display:grid; gap:2px }
    .hero{ font-size:var(--fz-36); font-weight:800; line-height:1.0; letter-spacing:.2px; color:#cfe6ff; text-shadow: 0 6px 18px rgba(114,168,255,.18) }
    .caption{ color:var(--muted); font-size:var(--fz-12) }
    .svc{ font-weight:800; color:var(--accent-2) }

    table{width:100%; border-collapse:collapse; margin-top:12px}
    th,td{border-bottom:1px dashed #203043; padding:9px 6px; text-align:left; font-size:var(--fz-13)}
    th{color:var(--muted); font-weight:700}
    .code{font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size:12px; color:#cfe1ff}
    .money{font-weight:800}

    .break { margin:6px 0 10px; background:#0b1424; border:1px solid var(--line); border-radius:10px; }
    .break table{ width:100%; border-collapse:collapse; }
    .break th,.break td{ border:0; padding:6px 8px; text-align:left; font-size:12px; }
    .break .codepill{ display:inline-block; padding:2px 8px; border:1px solid var(--line); border-radius:999px; font-family:ui-monospace,Menlo,Consolas,monospace; font-size:12px; color:#cfe1ff; background:#0e1a30; }
    .break .colhed{ color:var(--muted); font-weight:600; }

    :focus-visible{ outline:2px solid var(--accent); outline-offset:2px; border-radius:8px }
    @media print{ header,.bar{display:none} body{background:#fff; color:#000} .tier{break-inside:avoid; border:1px solid #000; box-shadow:none} table, th, td{border-color:#000} }
  </style>
</head>
<body>
  <header>
    <div>
      <h1>PayerEdge — VSP Bundles</h1>
      <div class="sub">Scoreboard shows <b>patient copay</b> and <b>service fee</b> (Copay − Holdback). Sun choices are exclusive.</div>
    </div>
    <div class="version sub" id="version">loading…</div>
  </header>

  <main>
    <div class="bar" role="toolbar" aria-label="Bundle controls">
      <div class="group">
        <button class="btn" id="forceRefresh" title="Reload CSV and recompute">Force Refresh</button>
        <button class="btn" id="clearCache" title="Clear local CSV cache">Clear Cache</button>
      </div>
      <div class="group">
        <label class="switch">Lens family
          <select id="lensFamily" aria-label="Lens family">
            <option value="SV" selected>Single Vision</option>
            <option value="LINED">Lined Bi/Tri</option>
            <option value="PAL">Progressive</option>
          </select>
        </label>
        <label class="switch">Lens tint
          <select id="lensTint" aria-label="Lens tint">
            <option value="clear" selected>Clear</option>
            <option value="tint-solid">Solid Tint</option>
            <option value="tint-gradient">Gradient Tint</option>
            <option value="polarized">Polarized</option>
            <option value="transitions">Transitions®</option>
          </select>
        </label>
      </div>
      <div class="group">
        <label class="switch"><input type="checkbox" id="includeAR" checked> Include AR (tiered)</label>
        <label class="switch"><input type="checkbox" id="includeAspheric"> Aspheric</label>
        <label class="switch"><input type="checkbox" id="includeOversize"> Oversize</label>
        <label class="switch"><input type="checkbox" id="includeGlass"> Glass</label>
        <label class="switch"><input type="checkbox" id="includeCM"> Custom measurements (N/O only)</label>
      </div>
      <span id="status" aria-live="polite"></span>
    </div>

    <div id="stack" class="stack"></div>
  </main>

  <!-- Error overlay -->
  <script>
    if (!window.__PAYEREDGE_V174__) {
      (function(){
        function showErrorOverlay(err, where){
          const wrap = document.createElement('div');
          wrap.style.cssText = 'position:fixed;inset:12px;z-index:99999;background:#0b1220;border:1px solid #f44;box-shadow:0 8px 24px rgba(0,0,0,.5);color:#fff;border-radius:12px;padding:12px;overflow:auto;max-height:90vh;font:12px/1.4 ui-monospace,Menlo,Consolas,monospace';
          wrap.innerHTML = '<b>JS Error @ '+where+':</b><pre style="white-space:pre-wrap;margin:8px 0 0">'+
            (err && (err.stack||err.message||String(err))) + '</pre>';
          document.body.appendChild(wrap);
        }
        window.addEventListener('error', e=>showErrorOverlay(e.error||e,'window.error'));
        window.addEventListener('unhandledrejection', e=>showErrorOverlay(e.reason||e,'unhandledrejection'));
      })();
    }
  </script>

  <script>
  if (window.__PAYEREDGE_V174__) {
    console.warn('PayerEdge APP script already loaded; skipping second init.');
  } else {
    window.__PAYEREDGE_V174__ = true;

    /* ================== Config & utils ================== */

    const CSV_CANDIDATES = [
      './vsp_choice_master_v7_full_fixed_patched.csv',
      './vsp_choice_master_v7_full_fixed.csv',
      './data/vsp_choice_master_v7_full_fixed_patched.csv',
      './data/vsp_choice_master_v7_full_fixed.csv'
    ];

    const BETTER_CAP_OF_MAX = 0.75;
    const GOOD_CAP_OF_MAX   = 0.50;
    const CAP_RELAX_FACTOR  = 0.90;

    const el = (id)=>document.getElementById(id);
    const sum = (a)=>a.reduce((x,y)=>x+y,0);
    const num = (v)=>{ const x=parseFloat(String(v??'').replace(/[^0-9.-]/g,'')); return isFinite(x)?x:0; };
    const quickHash=(s)=>{ let h=2166136261>>>0; for(let i=0;i<s.length;i++){ h^=s.charCodeAt(i); h=Math.imul(h,16777619)>>>0; } return ('00000000'+h.toString(16)).slice(-8); };
    const N = s => String(s||'').toLowerCase();

    const isDCode  = r => /^d/i.test((r.code||'').trim());

    /* ===== Code/material understanding ===== */
    // Glass base by A-code
    const GLASS_BASE_CODES = new Set(['AF','DE','FE']); // extend if your CSV has more
    const baseCodeOf = row => {
      const raw = String(row?.code || '').trim().toUpperCase();
      const parts = raw.split(/[\s+&/,\-]+/).filter(Boolean);
      return parts[0] || raw;
    };
    const isGlassByCode = row => GLASS_BASE_CODES.has(baseCodeOf(row));
    const isGlassText   = s => /glass/i.test(String(s||''));
    const isGlassBase   = row => isGlassByCode(row) || isGlassText(row?.enhancement) || isGlassText(row?.subtype);

    const preferPhotoCodeForBase = row => (isGlassBase(row) ? 'PM' : 'PR'); // Transitions PR vs PM

    const splitCodes = (s)=> String(s||'')
      .toUpperCase().replace(/[^\w+&/,\s-]/g,'')
      .split(/[\s+&/,\-]+/).map(t=>t.trim()).filter(Boolean);

    function parseCopayNumbers(copayStr){
      const m = String(copayStr||'').match(/[0-9]+(?:\.[0-9]{1,2})?/g);
      return m ? m.map(x=>parseFloat(x)) : [];
    }

    function parseCSV(text){
      const rows=[]; let row=[], field='', q=false;
      for(let i=0;i<text.length;i++){
        const ch=text[i];
        if(ch==='\"'){ if(q && text[i+1]==='\"'){ field+='\"'; i++; } else { q=!q; } continue; }
        if(!q && ch===','){ row.push(field); field=''; continue; }
        if(!q && (ch==='\n' || ch==='\r')){ if(field!==''||row.length){ row.push(field); rows.push(row); row=[]; field=''; } continue; }
        field+=ch;
      }
      if(field!==''||row.length){ row.push(field); rows.push(row); }
      const headers = rows.shift().map(h=>h.replace(/^\"|\"$/g,'').trim());
      return rows.filter(r=>r.length>=headers.length).map(r=>{
        const o={}; headers.forEach((h,i)=>o[h]=(r[i]||'').replace(/^\"|\"$/g,'').trim()); return o;
      });
    }

    const CACHE_KEY='rev-vsp-choice-csv-v1';
    const META_KEY='rev-vsp-choice-meta-v1';
    const setCache=(t,m)=>{ localStorage.setItem(CACHE_KEY,t); localStorage.setItem(META_KEY,JSON.stringify(m)); };
    const getCache=()=>({ text: localStorage.getItem(CACHE_KEY), meta: JSON.parse(localStorage.getItem(META_KEY)||'{}') });
    const clearCacheStorage=()=>{ localStorage.removeItem(CACHE_KEY); localStorage.removeItem(META_KEY); };

    let DATA=[];
    let SIMPLE_BY_CODE = new Map(); // code -> array of single-code rows

    function buildSimpleIndex(){
      SIMPLE_BY_CODE = new Map();
      for (const r of DATA){
        const parts = splitCodes(r.code);
        if (parts.length === 1){
          const code = parts[0];
          if (!SIMPLE_BY_CODE.has(code)) SIMPLE_BY_CODE.set(code, []);
          SIMPLE_BY_CODE.get(code).push(r);
        }
      }
    }

    function pickBaseByExactCode(baseCode){
      const list = SIMPLE_BY_CODE.get(baseCode) || [];
      if (!list.length) return null;
      const score = s => (s.includes('plastic') && !s.includes('high') ? 2 : 0);
      return list
        .map(r => ({ r, s: (r.enhancement || r.subtype || '').toLowerCase() }))
        .sort((a,b) => score(b.s) - score(a.s))[0].r;
    }

    async function tryFetch(url){
      try{
        const res = await fetch(url, { cache:'no-store' });
        if(!res.ok) throw new Error('HTTP '+res.status);
        const text = await res.text();
        return { ok:true, text, url };
      }catch(e){
        return { ok:false, err:String(e), url };
      }
    }

    async function loadCSV(){
      const status=el('status'); status.textContent=' loading…';
      const tried = [];
      let loaded = null;

      for (const url of CSV_CANDIDATES){
        const r = await tryFetch(url);
        tried.push(r);
        if (r.ok){ loaded = r; break; }
      }

      if (loaded){
        const meta = { plan:'VSP_choice', version:new Date().toISOString().slice(0,10)+'.ui17.4', source:'network:'+loaded.url, sha:quickHash(loaded.text) };
        setCache(loaded.text, meta);
        DATA = parseCSV(loaded.text);
        buildSimpleIndex();
        renderMeta(DATA.length, meta);
        status.textContent = ` [ok] ${loaded.url} • ${DATA.length} rows`;
        computeBundles();
        return;
      }

      const {text, meta} = getCache();
      if(text){
        DATA = parseCSV(text);
        buildSimpleIndex();
        renderMeta(DATA.length, {...meta, source:'cache'});
        status.textContent = ` Network failed. Using cached data (${DATA.length} rows).`;
        computeBundles();
        return;
      }

      const diag = document.createElement('div');
      diag.style.cssText = 'margin-top:12px; padding:10px; border:1px solid #843; background:#1a0f16; color:#f8cdd5; border-radius:10px; font-size:13px';
      const urls = CSV_CANDIDATES.map(u => `<li><code>${u}</code></li>`).join('');
      const errs = tried.map(t => `<li><code>${t.url}</code> → ${t.ok ? 'OK' : t.err}</li>`).join('');
      let hint = '';
      if (location.protocol === 'file:') {
        hint = `<div style="margin-top:6px">Open via a local server:
                <br/><code>python -m http.server 8080</code> → <code>http://localhost:8080/app.html</code></div>`;
      }
      diag.innerHTML = `
        <b>Load failed — no cache available.</b>
        <div style="margin-top:6px">Tried these paths (first wins):</div>
        <ul>${urls}</ul>
        <div style="margin-top:6px">Results:</div>
        <ul>${errs}</ul>${hint}`;
      el('status').textContent = ' load failed (see diagnostics below)';
      document.querySelector('main').appendChild(diag);
    }

    function renderMeta(count, meta){
      el('version').textContent = `plan=${meta.plan||'VSP_choice'} • rows=${count||0} • version=${meta.version||'—'} • source=${meta.source||'—'} • sha=${meta.sha||'—'}`;
    }

    const byKey=(k)=>DATA.filter(r=>(r.active||'yes').toLowerCase()==='yes' && (r.exclusive_key||'').toLowerCase()===k);
    function applies(row, fam){
      const a=(row.applies_to||'ALL').toUpperCase();
      if(a.includes('ALL')) return true;
      if(fam==='SV')     return a.includes('SV');
      if(fam==='LINED')  return a.includes('OCC');
      if(fam==='PAL')    return a.includes('MF');
      return true;
    }

    /* ===== Per-line math (UNIVERSAL composite handling) ===== */
    function line(row){
      const desc = row.enhancement || row.subtype || '—';
      const codeStr = String(row.code||'').trim().toUpperCase();
      const partsCodes = splitCodes(codeStr);

      // Single-code line → direct
      if (partsCodes.length === 1){
        const cop = num(row.copay), cb = num(row.chargeback);
        return { name:desc, code:codeStr, copay:cop, chargeback:cb, profit:cop-cb, parts:[] };
      }

      // COMPOSITE
      const compositeCopayNums  = parseCopayNumbers(row.copay);
      const compositeTotalCopay = num(row.copay);
      const compositeAddOnCB    = num(row.chargeback);
      const ctx                 = (row.enhancement || row.subtype || '').toLowerCase();

      // Material-aware single-row picker for a given code
      function pickSimpleMatched(code){
        const cands = SIMPLE_BY_CODE.get(code) || [];
        if (!cands.length) return null;

        function score(r){
          const t = (r.enhancement || r.subtype || '').toLowerCase();
          let s = 0;

          // broad buckets
          if (/polycarb/.test(ctx) && /polycarb/.test(t)) s += 6;
          if (/trivex/.test(ctx)   && /trivex/.test(t))   s += 6;
          if (/glass/.test(ctx)    && /glass/.test(t))    s += 6;
          if (/(cr[\s-]?39|plastic)/.test(ctx) && /(cr[\s-]?39|plastic)/.test(t) && !/high/.test(t)) s += 4;

          // high-index matching
          if (/1\.66|1\.67/.test(ctx) && /1\.66|1\.67/.test(t)) s += 9;
          if (/1\.70|1\.71/.test(ctx) && /1\.70|1\.71/.test(t)) s += 8;
          if (/1\.74|1\.75/.test(ctx) && /1\.74|1\.75/.test(t)) s += 8;
          if (/1\.53|1\.60/.test(ctx) && /1\.53|1\.60/.test(t)) s += 6;

          // avoid sun-tech rows for add-ons
          if (/polariz|photochrom|transitions|tint|tinted|gradient|sunglass/.test(t)) s -= 20;

          // prefer “true single” rows
          if (splitCodes(String(r.code||'')).length === 1) s += 1;

          return s;
        }

        return cands.slice().sort((a,b)=>score(b)-score(a))[0] || cands[0];
      }

      const parts = [];

      // Base (A-code)
      const baseCode  = partsCodes[0];
      const baseRow   = pickBaseByExactCode(baseCode) || pickSimpleMatched(baseCode);
      const baseCopay = (compositeCopayNums.length >= partsCodes.length)
        ? num(compositeCopayNums[0])     // explicit split like "45 + 58"
        : (baseRow ? num(baseRow.copay) : compositeTotalCopay);
      const baseCB    = baseRow ? num(baseRow.chargeback) : 0;

      parts.push({ code:baseCode, copay:baseCopay, chargeback:baseCB, profit:baseCopay-baseCB });

      // Add-ons
      const addonCount = partsCodes.length - 1;

      // optional explicit splits from CSV
      let addonCopays = [];
      if (compositeCopayNums.length >= partsCodes.length){
        addonCopays = compositeCopayNums.slice(1).map(num);
      } else {
        const remaining = Math.max(compositeTotalCopay - baseCopay, 0);
        const each = addonCount ? (remaining / addonCount) : 0;
        addonCopays = Array.from({length:addonCount}, ()=>each);
      }

      for (let i=1;i<partsCodes.length;i++){
        const code   = partsCodes[i];
        const simple = pickSimpleMatched(code);

        // copay preference: explicit split → matched single-row → fallback split
        let cop = addonCopays[i-1];
        if (!(isFinite(cop) && cop > 0)){
          cop = simple ? num(simple.copay) : addonCopays[i-1];
        }

        // holdback preference: matched single-row → apportioned composite holdback
        let cb = simple ? num(simple.chargeback) : 0;
        if (!simple){
          cb = (addonCount <= 1) ? compositeAddOnCB : (compositeAddOnCB / addonCount);
        }

        parts.push({ code, copay:cop, chargeback:cb, profit:cop-cb });
      }

      const totalCop = parts.reduce((a,x)=>a+x.copay,0);
      const totalCB  = parts.reduce((a,x)=>a+x.chargeback,0);
      return { name:desc, code:codeStr, copay:totalCop, chargeback:totalCB, profit:totalCop-totalCB, parts };
    }

    function makeBundle(base, addOns){
      const rows = [base, ...addOns.filter(Boolean)];
      const lines = rows.map(line);
      const cop = sum(lines.map(x=>x.copay));
      const cb  = sum(lines.map(x=>x.chargeback));
      const pr  = cop - cb;
      const ratio = cop>0 ? (pr/cop) : 0;
      const label = base.enhancement || base.subtype || base.code || 'Base';
      return { label, lines, copay:cop, chargeback:cb, profit:pr, ratio };
    }

    /* ===== UI helpers ===== */
    function animateNumber(el,to){
      const from=parseFloat(el.getAttribute('data-prev')||'0'); const start=performance.now(); const dur=380;
      function step(t){ const k=Math.min(1,(t-start)/dur); const v=from+(to-from)*(0.5-Math.cos(Math.PI*k)/2); el.textContent=`$${v.toFixed(2)}`; if(k<1)requestAnimationFrame(step); else el.setAttribute('data-prev',to); }
      requestAnimationFrame(step);
    }
    const tdMoney = v => `<td class="money">$${v.toFixed(2)}</td>`;

    function renderTier({name, cls, b}){
      const div=document.createElement('div'); div.className='tier';
      if(!b){
        div.innerHTML=`<div class="tierHead"><div class="stars ${cls}"><span class="tag">${name}</span></div><div class="figures"><div class="hero">—</div><div class="caption">Patient Copay</div></div></div><div class="sub">No viable bundle</div>`;
        return div;
      }
      const stars = name==='Best' ? '★★★' : name==='Better' ? '★★' : name==='Good' ? '★' : '◎';
      const head = `
        <div class="tierHead">
          <div class="stars ${cls}">
            <div aria-label="${name}" title="${name}" style="font-size:18px">${stars}</div>
            <span class="tag">${b.label}</span>
          </div>
          <div class="figures">
            <div class="hero" aria-label="Patient Copay" data-prev="0">$${b.copay.toFixed(2)}</div>
            <div class="caption">Patient Copay</div>
            <div class="caption">Service Fee (Practice Profit): <span class="svc">$${b.profit.toFixed(2)}</span></div>
          </div>
        </div>`;

      const lines = b.lines.map(li=>{
        const main = `
          <tr>
            <td>${li.name}</td>
            <td class="code">${li.code || '—'}</td>
            ${tdMoney(li.copay)}
            ${tdMoney(li.chargeback)}
            ${tdMoney(li.profit)}
          </tr>`;

        const parts = (li.parts && li.parts.length)
          ? `
            <tr>
              <td colspan="5">
                <div class="break">
                  <table>
                    <thead>
                      <tr>
                        <th class="colhed" style="width:120px">Code</th>
                        <th class="colhed">Copay</th>
                        <th class="colhed">Holdback</th>
                        <th class="colhed">Service Fee</th>
                      </tr>
                    </thead>
                    <tbody>
                      ${li.parts.map(p=>`
                        <tr>
                          <td><span class="codepill">${p.code}</span></td>
                          ${tdMoney(p.copay)}
                          ${tdMoney(p.chargeback)}
                          ${tdMoney(p.profit)}
                        </tr>`).join('')}
                    </tbody>
                  </table>
                </div>
              </td>
            </tr>`
          : '';

        return main + parts;
      }).join('');

      div.innerHTML = head + `
        <table>
          <thead>
            <tr>
              <th>Item</th>
              <th>Code</th>
              <th class="nowrap">Copay</th>
              <th class="nowrap">Holdback</th>
              <th class="nowrap">Service Fee</th>
            </tr>
          </thead>
          <tbody>${lines}</tbody>
          <tfoot>
            <tr>
              <th colspan="2" style="text-align:right">Totals</th>
              ${tdMoney(b.copay)}${tdMoney(b.chargeback)}${tdMoney(b.profit)}
            </tr>
          </tfoot>
        </table>`;
      const hero = div.querySelector('.hero'); animateNumber(hero, b.copay);
      return div;
    }
    function renderStack(rows){
      const stack = el('stack'); stack.innerHTML='';
      for(const row of rows){ stack.appendChild(renderTier(row)); }
    }

    /* ===== material & sun helpers ===== */
    function materialKey(label) {
      const s = N(label);
      if (s.includes('polycarb')) return 'poly';
      if (s.includes('trivex')) return 'trivex';
      if (/1\.74|1\.75/.test(s)) return 'hi174';
      if (/1\.70|1\.71|above/.test(s)) return 'hi70';
      if (/1\.66|1\.67/.test(s)) return 'hi167';
      if (/cr[\s-]?39/.test(s) || (s.includes('plastic') && !s.includes('high'))) return 'cr39';
      if (s.includes('glass')) return 'glass';
      return 'other';
    }

    // Strict glass policy (code/text aware)
    function enforceGlassPolicy(rows, wantGlassOnly){
      return rows.filter(r => wantGlassOnly ? isGlassBase(r) : !isGlassBase(r));
    }

    function sunMatchesBase(sunRow, baseRow) {
      const mk = materialKey(baseRow.enhancement || baseRow.subtype || '');
      const t = N(sunRow.enhancement || sunRow.subtype || '');
      switch (mk) {
        case 'poly':   return /polycarb/.test(t);
        case 'trivex': return /trivex/.test(t);
        case 'hi174':  return /(1\.74|1\.75)/.test(t);
        case 'hi70':   return /(1\.70|1\.71|above)/.test(t);
        case 'hi167':  return /(1\.66|1\.67)/.test(t);
        case 'glass':  return /glass/.test(t);
        case 'cr39':   return (/(cr[\s-]?39|plastic)/.test(t) && !/high/.test(t));
        default:       return true;
      }
    }

    // PAL polarized base identification: NP / OP (or composites containing them)
    function isPolarizedPAL(row){
      const parts = splitCodes(String(row.code||'').trim().toUpperCase());
      return parts.includes('NP') || parts.includes('OP');
    }

    // PAL N/O base eligibility for CM: base must begin NA or OA
    function isNOBase(row){
      const code = baseCodeOf(row);
      return code.startsWith('NA') || code.startsWith('OA');
    }

    function chooseTransitionsFor(baseRow){
      const fam = el('lensFamily').value;
      const wantGlassOnly = el('includeGlass').checked;
      const PHOTO_RX = /(photochrom|transitions)/i;
      const all = enforceGlassPolicy(
        byKey('sun_tech').filter(r=>applies(r,fam)),
        wantGlassOnly
      ).filter(r => PHOTO_RX.test(r.enhancement||r.subtype||''));
      const want = preferPhotoCodeForBase(baseRow); // PM for glass, else PR
      let best = all.find(r => new RegExp('^'+want+'\\b','i').test((r.code||'').trim()));
      if (!best){
        const pool = all.filter(r => sunMatchesBase(r, baseRow));
        best = pool[0] || all[0] || null;
      }
      return best || null;
    }

    // Tint pickers (MN/MP preferred; fallback to sun_tech tint)
    function pickTintRow(baseRow, variant){
      const fam = el('lensFamily').value;
      const wantGlassOnly = el('includeGlass').checked;
      const baseIsGlass = wantGlassOnly || isGlassBase(baseRow);

      let candidates = []
        .concat(SIMPLE_BY_CODE.get('MN')||[])
        .concat(SIMPLE_BY_CODE.get('MP')||[])
        .filter(r => applies(r, fam));

      candidates = candidates.filter(r => baseIsGlass ? isGlassBase(r) : !isGlassBase(r));

      const wantGrad  = variant === 'tint-gradient';
      const wantSolid = variant === 'tint-solid';
      const hasVariant = r => {
        const t=N(r.enhancement||r.subtype||'');
        if (wantGrad)  return /gradient|grad/i.test(t);
        if (wantSolid) return /solid/.test(t) || (/tint/i.test(t) && !/gradient/i.test(t));
        return true;
      };
      let pool = candidates.filter(hasVariant);
      if (!pool.length) pool = candidates;

      const mk = materialKey(baseRow.enhancement || baseRow.subtype || '');
      const score = (r)=>{
        const t=N(r.enhancement||r.subtype||''); let s=0;
        if (mk==='poly'   && /polycarb/.test(t)) s+=3;
        if (mk==='trivex' && /trivex/.test(t))   s+=3;
        if (mk==='glass'  && /glass/.test(t))    s+=3;
        if (mk==='cr39'   && /(cr[\s-]?39|plastic)/.test(t) && !/high/.test(t)) s+=2;
        if (wantGrad && /gradient/.test(t)) s+=1;
        if (wantSolid && /solid/.test(t))   s+=1;
        return s;
      };
      return pool.sort((a,b)=>score(b)-score(a))[0] || null;
    }

    function chooseTintSunFallback(baseRow, variant){
      const fam = el('lensFamily').value;
      const wantGlassOnly = el('includeGlass').checked;
      const wantGrad  = variant === 'tint-gradient';
      const wantSolid = variant === 'tint-solid';

      let pool = enforceGlassPolicy(
        byKey('sun_tech').filter(r=>applies(r,fam)),
        wantGlassOnly
      ).filter(r=>{
        const t = N(r.enhancement||r.subtype||'');
        if (/(polariz|photochrom|transitions)/i.test(t)) return false;
        if (!/tint|tinted|sunglass|gradient/.test(t))    return false;
        if (wantGrad)  return /gradient|grad/i.test(t);
        if (wantSolid) return /solid/.test(t) || (/tint/i.test(t) && !/gradient/i.test(t));
        return true;
      });

      pool = pool.sort((a,b)=>{
        const aM = sunMatchesBase(a, baseRow) ? 1 : 0;
        const bM = sunMatchesBase(b, baseRow) ? 1 : 0;
        return bM - aM;
      });
      return pool[0] || null;
    }

    /* ===== Compute bundles ===== */
    function computeBundles(){
      if(!DATA.length){ el('stack').innerHTML=''; return; }

      const fam = el('lensFamily').value;
      const wantAR = el('includeAR').checked;
      const wantAsp = el('includeAspheric').checked;
      const wantOS  = el('includeOversize').checked;
      const wantGlassOnly = el('includeGlass').checked;
      const tintSel = el('lensTint').value;

      const customPool = DATA.filter(r => applies(r, 'PAL'))
                             .filter(r => /custom\s*measure/i.test(N(r.enhancement||r.subtype||'')));

      let base = [];

      if (fam === 'PAL') {
        // PAL: progressive materials. Polarized → NP/OP (NOT D-codes)
        base = byKey('progressive_level').filter(r=>applies(r,fam)).filter(r=>{
          const name=N(r.enhancement||r.subtype||'');
          const code=String(r.code||'').toUpperCase();
          if(!wantAsp && name.includes('aspheric')) return false;
          if (/photochrom|tint|tinted|sunglass|gradient/.test(name)) return false;
          if (tintSel==='polarized') return isPolarizedPAL(r);  // NP/OP
          return !/polariz/i.test(name) && !/NP|OP/.test(code);
        });
        base = enforceGlassPolicy(base, wantGlassOnly);
      } else {
        if (tintSel==='polarized') {
          // SV/LINED: D-coded polarized base (exclusive)
          base = byKey('sun_tech')
            .filter(r => applies(r, fam))
            .filter(r => /polariz/i.test(r.enhancement || r.subtype || ''))
            .filter(isDCode);
        } else {
          // Normal SV or LINED bases
          const pool = (fam==='SV' ? byKey('base_material') : byKey('occupational'));
          base = pool.filter(r=>applies(r,fam)).filter(r=>{
            const name=N(r.enhancement||r.subtype||'');
            if(!wantAsp && name.includes('aspheric')) return false;
            if(/photochrom|polariz|tint|tinted|sunglass|gradient/.test(name)) return false;
            return true;
          });
          base = enforceGlassPolicy(base, wantGlassOnly); // exposes AF/DE/FE when Glass=ON
        }
      }

      // AR ranked by grade then profit
      function rankAR(ars){
        const gradeVal = (s)=>{ const m=String(s||'').match(/\b([A-D])\b/i); if(!m) return null; return {A:1,B:2,C:3,D:4}[m[1].toUpperCase()]||null; };
        return [...ars].sort((a,b)=>{
          const ga=gradeVal(a.enhancement||a.subtype)||-1, gb=gradeVal(b.enhancement||b.subtype)||-1;
          if(ga!==gb) return gb-ga; // prefer A
          const pa=num(a.copay)-num(a.chargeback);
          const pb=num(b.copay)-num(b.chargeback);
          return pb-pa;
        });
      }
      const arPool = wantAR ? byKey('ar_level').filter(r=>applies(r,fam)) : [];
      const arRanked = wantAR ? rankAR(arPool) : [];
      const arOptions = wantAR && arRanked.length ? arRanked : [null];

      const overs = wantOS ? (byKey('oversize').filter(r=>applies(r,fam))[0] || null) : null;

      function computeAddOnsFor(baseRow){
        const addOns = [];

        if (tintSel==='transitions'){
          const tr = chooseTransitionsFor(baseRow);
          if (tr) addOns.push(tr);
        }

        if (tintSel==='tint-solid' || tintSel==='tint-gradient'){
          const tintRow = pickTintRow(baseRow, tintSel) || chooseTintSunFallback(baseRow, tintSel);
          if (tintRow) addOns.push(tintRow);
        }

        // CM only for PAL when base begins with NA or OA
        if (el('includeCM')?.checked && fam==='PAL' && isNOBase(baseRow)){
          if (customPool.length) addOns.push(customPool[0]);
        }

        if (overs) addOns.push(overs);
        return addOns;
      }

      function buildBundle(m, arRow){
        // For SV/LINED + Polarized: exclusive (no tint add-ons). For PAL, NP/OP already in base.
        const addOns = (tintSel==='polarized' && fam!=='PAL') ? [] : computeAddOnsFor(m);
        return makeBundle(m, [arRow, ...addOns]);
      }

      const all = [];
      for(const m of base){ for(const ar of arOptions){ all.push(buildBundle(m, ar)); } }
      if (!all.length){
        renderStack([
          {name:'Best',cls:'best',b:null},
          {name:'Better',cls:'better',b:null},
          {name:'Good',cls:'good',b:null},
          {name:'Cheapest',cls:'good',b:null}
        ]);
        return;
      }

      // Tiers
      const MaxPrice = Math.max(...all.map(b => b.copay));
      function mostProfit(arr){
        let pick=null;
        for(const b of arr){ if(!pick || b.profit>pick.profit || (b.profit===pick.profit && b.copay<pick.copay)) pick=b; }
        return pick;
      }
      function mostProfitUnderCap(cap, exclude=new Set()){
        let pick=null, bestProfit=-Infinity;
        for(const b of all){
          if (b.copay <= cap){
            const lbl=b.label;
            if (exclude.has(lbl)) continue;
            if (b.profit>bestProfit || (b.profit===bestProfit && b.copay<(pick?.copay??Infinity))){
              bestProfit=b.profit; pick=b;
            }
          }
        }
        if (pick) return pick;
        const looser = cap / CAP_RELAX_FACTOR;
        for(const b of all){
          if (b.copay <= looser){
            const lbl=b.label; if (exclude.has(lbl)) continue;
            if (!pick || b.profit>pick.profit || (b.profit===pick.profit && b.copay<pick.copay)) pick=b;
          }
        }
        return pick;
      }
      function cheapest(exclude=new Set()){
        let pick=null;
        for(const b of all){
          const lbl=b.label; if (exclude.has(lbl)) continue;
          if (!pick || b.copay < pick.copay || (b.copay===pick.copay && b.profit>(pick.profit))) pick=b;
        }
        if (pick) return pick;
        for(const b of all){
          if (!pick || b.copay < pick.copay || (b.copay===pick.copay && b.profit>(pick.profit))) pick=b;
        }
        return pick;
      }

      const best = mostProfit(all);
      const used = new Set(best ? [best.label] : []);
      const better = mostProfitUnderCap(MaxPrice*BETTER_CAP_OF_MAX, used);
      if (better) used.add(better.label);
      let good = mostProfitUnderCap(MaxPrice*GOOD_CAP_OF_MAX, used);
      if (!good) good = cheapest(used);
      if (good) used.add(good.label);
      const cheap = cheapest(used);

      renderStack([
        {name:'Best',     cls:'best',    b:best},
        {name:'Better',   cls:'better',  b:better},
        {name:'Good',     cls:'good',    b:good},
        {name:'Cheapest', cls:'good',    b:cheap}
      ]);
    }

    /* Wire-up */
    el('forceRefresh').onclick=()=>{ clearCacheStorage(); loadCSV(); };
    el('clearCache').onclick =()=>{ clearCacheStorage(); el('status').textContent=' cache cleared — click Force Refresh to reload'; };
    ['lensFamily','lensTint','includeAR','includeAspheric','includeOversize','includeGlass','includeCM']
      .forEach(id => { const node=el(id); if(node) node.onchange=computeBundles; });

    (function boot(){ loadCSV(); })();
  }
  </script>
</body>
</html>
