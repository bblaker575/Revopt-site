<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>PayerEdge — VSP Bundles</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
  <style>
    :root{
      --bg:#090e16;--bg-elev:#0c1320;--fg:#eaf1ff;--muted:#9fb0c9;--line:#263448;--accent:#72a8ff;--accent-2:#7be0c3;
      --tier-best:#ffd166;--tier-better:#a9c2ff;--tier-good:#7be0c3;
      --shadow-lg:0 18px 40px rgba(0,0,0,.35);--shadow-md:0 10px 26px rgba(0,0,0,.28);
      --radius:18px;
      --w-item:34%; --w-code:20%; --w-money:23%;
    }
    *{box-sizing:border-box} html,body{height:100%}
    body{
      margin:0;background:
        radial-gradient(1200px 600px at 20% -10%, rgba(90,168,255,.12), transparent 60%),
        radial-gradient(900px 500px at 110% 10%, rgba(123,224,195,.10), transparent 60%),
        var(--bg);
      color:var(--fg);font:15px/1.45 Inter,system-ui,-apple-system,"Segoe UI",Roboto,sans-serif;
      -webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;font-variant-numeric:tabular-nums
    }
    header{position:sticky;top:0;z-index:20;display:flex;justify-content:space-between;align-items:center;gap:14px;padding:12px 16px;
      background:linear-gradient(180deg, rgba(9,14,22,.95), rgba(9,14,22,.78));border-bottom:1px solid var(--line);backdrop-filter:blur(10px)}
    h1{margin:0;font-weight:800;font-size:clamp(16px,1.8vw,20px)}
    .sub{color:var(--muted);font-size:12px}
    main{padding:14px}
    .bar{display:flex;align-items:center;flex-wrap:wrap;gap:10px 12px;background:linear-gradient(180deg,var(--bg-elev),#0b1220);
      border:1px solid var(--line);border-radius:18px;padding:10px;box-shadow:var(--shadow-md)}
    .group{display:flex;gap:8px;align-items:center;padding:6px 8px;border-radius:999px;background:#0b1424}
    .btn{background:#121f35;border:1px solid var(--line);color:var(--fg);padding:6px 9px;border-radius:12px;cursor:pointer;font-weight:600;transition:.15s}
    .btn:hover{background:#162844;border-color:#2e4260}
    .switch{display:inline-flex;align-items:center;gap:8px}
    select{background:#0e1a30;color:#fff;border:1px solid var(--line);border-radius:10px;padding:6px 8px;outline:none}
    select:focus{box-shadow:0 0 0 3px rgba(114,168,255,.25)}
    #status{margin-left:auto;padding:6px 10px;border-radius:999px;border:1px dashed var(--line);background:#0b1422;color:#c7d6ef;font-size:12px;max-width:52vw;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}

    .viewport-frame{transform-origin:top left;width:100%}
    .stack{display:grid;grid-template-columns:repeat(4,minmax(320px,1fr));gap:14px;align-items:stretch;margin-top:12px}
    .tier{background:linear-gradient(180deg,#0f1726,#0c1422);border:1px solid var(--line);border-radius:18px;box-shadow:var(--shadow-lg);padding:12px}
    .tierHead{display:grid;grid-template-columns:1fr auto;align-items:center;gap:10px;margin-bottom:8px}
    .stars{font-weight:800;display:flex;align-items:center;gap:8px}
    .stars.best{color:var(--tier-best)} .stars.better{color:var(--tier-better)} .stars.good{color:var(--tier-good)}
    .figures{text-align:right;display:grid;gap:2px}
    .hero{font-size:clamp(20px,2.6vw,36px);font-weight:600;line-height:1;letter-spacing:.2px;color:#cfe6ff}
    .caption{color:var(--muted);font-size:12px}
    .svc{font-weight:600;color:var(--accent-2)}
    table.bundle{width:100%;border-collapse:collapse;margin-top:8px;table-layout:fixed}
    th,td{border-bottom:1px dashed #203043;padding:8px 6px;font-size:12px;vertical-align:top}
    thead th{color:var(--muted);font-weight:700;line-height:1.15;white-space:nowrap}
    .bundle col:nth-child(1){width:var(--w-item)} .bundle col:nth-child(2){width:var(--w-code)}
    .bundle col:nth-child(3),.bundle col:nth-child(4){width:var(--w-money)}
    .cell-item{line-height:1.32;padding-bottom:2px}
    .cell-item .label{display:-webkit-box;-webkit-line-clamp:3;-webkit-box-orient:vertical;overflow:hidden;font-size:.95em}
    .cell-code{white-space:normal;word-break:break-word;overflow:visible;text-overflow:clip}
    .cell-money{white-space:nowrap;font-weight:600;text-align:right;font-size:clamp(11px,1.05vw,13px);
      font-variant-numeric:tabular-nums;padding-left:16px;padding-right:6px;min-width:110px}
    @media (max-width:900px){.stack{grid-template-columns:1fr}}

    /* OCR preview panel */
    .ocr-panel{margin-top:12px;display:grid;grid-template-columns:1.2fr 1fr;gap:12px}
    .card{background:linear-gradient(180deg,#0f1726,#0c1422);border:1px solid var(--line);border-radius:14px;padding:10px}
    .card h3{margin:0 0 6px 0;font-size:13px;color:#cfe6ff}
    .card pre{white-space:pre-wrap;word-break:break-word;font:12px/1.35 ui-monospace,Menlo,Consolas,monospace;color:#bcd3ff;max-height:260px;overflow:auto;margin:0}
    .kv{display:grid;grid-template-columns:1fr auto;gap:6px 10px}
    .kv .k{color:#9fb0c9}
    .kv .v{font-weight:700}
  </style>
</head>
<body>
<header>
  <div>
    <h1>PayerEdge — VSP Bundles</h1>
    <div class="sub">Scoreboard shows <b>patient copay</b> and <b>service fee</b>. Sun choices are exclusive.</div>
  </div>
  <div class="sub" id="version">loading…</div>
</header>

<main>
  <div class="bar" role="toolbar" aria-label="Bundle controls">
    <div class="group">
      <button class="btn" id="forceRefresh">Force Refresh</button>
      <button class="btn" id="clearCache">Clear Cache</button>
    </div>
    <div class="group">
      <label class="switch">Lens family
        <select id="lensFamily" aria-label="Lens family">
          <option value="SV" selected>Single Vision</option>
          <option value="LINED">Lined Bi/Tri</option>
          <option value="PAL">Progressive</option>
        </select>
      </label>
      <label class="switch">Lens tint
        <select id="lensTint" aria-label="Lens tint">
          <option value="clear" selected>Clear</option>
          <option value="tinted_solid">Tinted — Solid</option>
          <option value="tinted_gradient">Tinted — Gradient</option>
          <option value="polarized">Polarized</option>
          <option value="transitions">Transitions®</option>
        </select>
      </label>
    </div>
    <div class="group">
      <label class="switch"><input type="checkbox" id="includeAR" checked> Include AR (tiered)</label>
      <label class="switch"><input type="checkbox" id="includeAspheric"> Aspheric</label>
      <label class="switch"><input type="checkbox" id="includeOversize"> Oversize</label>
      <label class="switch"><input type="checkbox" id="includeGlass"> Glass</label>
      <label class="switch"><input type="checkbox" id="includeCM"> Custom measurements (N/O only)</label>
    </div>
    <!-- OCR group -->
    <div class="group">
      <button class="btn" id="scanBenefitsBtn">Scan Benefits (Camera)</button>
      <input id="scanBenefitsFile" type="file" accept=".pdf,image/*" capture="environment" style="display:none">
    </div>

    <span id="status" aria-live="polite"></span>
  </div>

  <div id="frame" class="viewport-frame">
    <div id="stack" class="stack"></div>
  </div>

  <!-- OCR preview and extracted values -->
  <div class="ocr-panel">
    <div class="card">
      <h3>OCR Text Preview</h3>
      <pre id="ocrText">—</pre>
    </div>
    <div class="card">
      <h3>Detected Benefits</h3>
      <div class="kv" id="ocrKV">
        <div class="k">Frame Allowance</div><div class="v" id="kv_frame">—</div>
        <div class="k">Exam Copay</div><div class="v" id="kv_exam">—</div>
        <div class="k">SV Lens Copay</div><div class="v" id="kv_sv">—</div>
        <div class="k">PAL Copay</div><div class="v" id="kv_pal">—</div>
        <div class="k">AR</div><div class="v" id="kv_ar">—</div>
        <div class="k">Photochromic</div><div class="v" id="kv_photo">—</div>
        <div class="k">Polarized</div><div class="v" id="kv_polar">—</div>
      </div>
    </div>
  </div>
</main>

<!-- OCR + PDF libs -->
<script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/pdfjs-dist@4.6.82/build/pdf.min.js"></script>
<script>
/* PDF.js worker (same CDN) */
pdfjsLib.GlobalWorkerOptions.workerSrc = "https://cdn.jsdelivr.net/npm/pdfjs-dist@4.6.82/build/pdf.worker.min.js";
</script>

<script>
if(!window.__PAYEREDGE_UI1694_HOTFIX__){
window.__PAYEREDGE_UI1694_HOTFIX__=true;

/* show JS errors in the status pill */
window.onerror = function(msg, src, line, col){
  const s=document.getElementById('status');
  if(s) s.textContent = ' script error: ' + msg + ' @' + (src||'') + ':' + (line||'?');
};

/* ---------- helpers (existing app) ---------- */
const CSV_CANDIDATES=[
  './vsp_choice_master_v8.4.csv',
  './data/vsp_choice_master_v8.4.csv',
  './vsp_choice_master_v7_full_fixed.csv'
];
const BETTER_CAP_OF_MAX=0.75, GOOD_CAP_OF_MAX=0.60, CAP_RELAX_FACTOR=0.90;

const el=id=>document.getElementById(id);
const sum=a=>a.reduce((x,y)=>x+y,0);
const num=v=>{ const x=parseFloat(String(v??'').replace(/[^0-9.-]/g,'')); return isFinite(x)?x:0; };
const quickHash=s=>{ let h=2166136261>>>0; for(let i=0;i<s.length;i++){ h^=s.charCodeAt(i); h=Math.imul(h,16777619)>>>0; } return ('00000000'+h.toString(16)).slice(-8); };
const N=s=>String(s||'').toLowerCase();
const isGlassName=name=>/glass/.test(N(name||''));
const splitCodes=s=>String(s||'').toUpperCase().replace(/[^\w+&/,\s-]/g,'').split(/[\s+&/,\-]+/).map(t=>t.trim()).filter(Boolean);
const parseCopayNumbers=s=>{ const m=String(s||'').match(/[0-9]+(?:\.[0-9]{1,2})?/g); return m?m.map(x=>parseFloat(x)):[]; };
function preferPhotoCodeForBase(row){ return isGlassName(row.enhancement||row.subtype)?'PM':'PR'; }
function parseSplitFromNotes(notes){
  const s=String(notes||'');
  const sv=s.match(/(\d+)\s*\+\s*(\d+)\s*\(SV\)/i);
  const mf=s.match(/(\d+)\s*\+\s*(\d+)\s*\(MF\)/i);
  return { svBase: sv?num(sv[1]):null, svAdd: sv?num(sv[2]):null, mfBase: mf?num(mf[1]):null, mfAdd: mf?num(mf[2]):null };
}

/* ---------- CSV + cache ---------- */
function parseCSV(text){
  const rows=[]; let row=[], field='', q=false;
  for(let i=0;i<text.length;i++){
    const ch=text[i];
    if(ch==='\"'){ if(q && text[i+1]==='\"'){ field+='\"'; i++; } else { q=!q; } continue; }
    if(!q && ch===','){ row.push(field); field=''; continue; }
    if(!q && (ch==='\n'||ch==='\r')){ if(field!==''||row.length){ row.push(field); rows.push(row); row=[]; field=''; } continue; }
    field+=ch;
  }
  if(field!==''||row.length){ row.push(field); rows.push(row); }
  const headers=rows.shift().map(h=>h.replace(/^\"|\"$/g,'').trim());
  return rows.filter(r=>r.length>=headers.length).map(r=>{ const o={}; headers.forEach((h,i)=>o[h]=(r[i]||'').replace(/^\"|\"$/g,'').trim()); return o; });
}
const CACHE_KEY='rev-vsp-choice-csv-v1', META_KEY='rev-vsp-choice-meta-v1';
const setCache=(t,m)=>{ localStorage.setItem(CACHE_KEY,t); localStorage.setItem(META_KEY,JSON.stringify(m)); };
const getCache=()=>({ text:localStorage.getItem(CACHE_KEY), meta: JSON.parse(localStorage.getItem(META_KEY)||'{}') });
const clearCacheStorage=()=>{ localStorage.removeItem(CACHE_KEY); localStorage.removeItem(META_KEY); };

let DATA=[], SIMPLE_BY_CODE=new Map();
function buildSimpleIndex(){
  SIMPLE_BY_CODE=new Map();
  for(const r of DATA){
    const parts=splitCodes(r.code);
    if(parts.length===1){
      const code=parts[0];
      if(!SIMPLE_BY_CODE.has(code)) SIMPLE_BY_CODE.set(code,[]);
      SIMPLE_BY_CODE.get(code).push(r);
    }
  }
}
function pickByCode(code){
  const fam=el('lensFamily').value;
  const wantGlass=el('includeGlass').checked;
  const list=(SIMPLE_BY_CODE.get(code)||[])
    .filter(r=>applies(r,fam))
    .filter(r=> wantGlass ? true : !isGlassName(r.enhancement||r.subtype));
  return list[0]||null;
}
function pickBaseByExactCode(baseCode){
  const list=SIMPLE_BY_CODE.get(baseCode)||[];
  if(!list.length) return null;
  const score=s=> (s.includes('plastic')&&!s.includes('high'))?2:0;
  return list.map(r=>({r,s:(r.enhancement||r.subtype||'').toLowerCase()})).sort((a,b)=>score(b.s)-score(a.s))[0].r;
}
async function tryFetch(url){
  try{ const res=await fetch(url,{cache:'no-store'}); if(!res.ok) throw new Error('HTTP '+res.status); return {ok:true,text:await res.text(),url}; }
  catch(e){ return {ok:false,err:String(e),url}; }
}
async function loadCSV(){
  const status=el('status'); status.textContent=' loading…';
  let loaded=null, tried=[];
  for(const url of CSV_CANDIDATES){ const r=await tryFetch(url); tried.push(url); if(r.ok){ loaded=r; break; } }
  if(loaded){
    const meta={plan:'VSP_choice',version:new Date().toISOString().slice(0,10)+'.ui16.9.4',source:'network:'+loaded.url,sha:quickHash(loaded.text)};
    setCache(loaded.text,meta); DATA=parseCSV(loaded.text); buildSimpleIndex(); renderMeta(DATA.length,meta);
    status.textContent = ` [ok] ${loaded.url} • ${DATA.length} rows`; computeBundles(); return;
  }
  const {text,meta}=getCache();
  if(text){ DATA=parseCSV(text); buildSimpleIndex(); renderMeta(DATA.length,{...meta,source:'cache'});
    status.textContent = ` Network failed. Using cached data (${DATA.length} rows).`; computeBundles(); return; }
  status.textContent = ' load failed — no cache (tried: ' + tried.join(', ') + ')';
}
function renderMeta(count,meta){
  el('version').textContent=`plan=${meta.plan||'VSP_choice'} • rows=${count||0} • version=${meta.version||'—'} • source=${meta.source||'—'} • sha=${meta.sha||'—'}`;
}

/* ---------- filters/pools / selection / rendering (unchanged except no Holdback column) ---------- */
const byKey=k=>DATA.filter(r=>(r.active||'yes').toLowerCase()==='yes' && (r.exclusive_key||'').toLowerCase()===k);
function applies(row,fam){
  const a=(row.applies_to||'ALL').toUpperCase();
  if(a.includes('ALL')) return true;
  if(fam==='SV') return a.includes('SV');
  if(fam==='LINED') return a.includes('OCC');
  if(fam==='PAL') return a.includes('MF');
  return true;
}
function sunPool(fam, wantGlass){
  const tag = r => (r.exclusive_key||'').toLowerCase();
  let pool = DATA.filter(r => (r.active||'yes').toLowerCase()==='yes' && applies(r,fam) &&
    (tag(r)==='sun_tech' || tag(r)==='sun'));
  const infer = DATA.filter(r=>{
    if((r.active||'yes').toLowerCase()!=='yes' || !applies(r,fam)) return false;
    const n=N(r.enhancement||r.subtype||'');
    return /(tint|tinted|sun|sunglass|photochrom|transitions|polariz)/.test(n);
  });
  if (!pool.length) pool = infer;
  pool = pool.filter(r=>{
    const n=N(r.enhancement||r.subtype||'');
    return wantGlass ? /glass/.test(n) : !/glass/.test(n);
  });
  return pool;
}
function chooseSunFor(baseRow){
  const tintSel=el('lensTint').value;
  const fam=el('lensFamily').value;
  const wantGlass=el('includeGlass').checked;
  const status=el('status');

  if(tintSel==='tinted_solid'){ const row = pickByCode('MN'); status.textContent = `tint: SOLID • code=MN${row?' • ok':''}`; return row; }
  if(tintSel==='tinted_gradient'){ const row = pickByCode('MP'); status.textContent = `tint: GRADIENT • code=MP${row?' • ok':''}`; return row; }
  if(tintSel==='polarized') return null;

  if(tintSel==='transitions'){
    const poolAll = sunPool(fam, wantGlass);
    const pool = poolAll.filter(r=>/photochrom|transitions/.test(N(r.enhancement)));
    const want=preferPhotoCodeForBase(baseRow);
    const choice = pool.find(r=>new RegExp('^'+want,'i').test((r.code||'').trim())) || pool.find(r=>/^p(m|r)/i.test((r.code||'').trim())) || null;
    status.textContent = `photochromic: poolAll=${poolAll.length} pool=${pool.length} want=${want}${choice?' • ok':''}`;
    return choice;
  }
  return null;
}
function parseLine(row){
  const desc=row.enhancement||row.subtype||'—';
  const codeStr=String(row.code||'').trim().toUpperCase();
  const partsCodes=splitCodes(codeStr);
  const notes=row.notes||row.note||row.Notes||row.NOTE||'';
  if(partsCodes.length===1){
    const cop=num(row.copay), cb=num(row.chargeback);
    return {name:desc,code:codeStr,copay:cop,chargeback:cb,profit:cop-cb,parts:[]};
  }
  const fam=el('lensFamily').value;
  const split=parseSplitFromNotes(notes);
  const compositeCopayNums=parseCopayNumbers(row.copay);
  const compositeTotalCopay=num(row.copay);
  const compositeAddOnCB=num(row.chargeback);

  const parts=[];
  const baseCode=partsCodes[0];
  const baseRow=pickBaseByExactCode(baseCode);
  let baseCop=baseRow?num(baseRow.copay):(compositeCopayNums[0]??compositeTotalCopay);
  let baseCB =baseRow?num(baseRow.chargeback):0;
  if(fam!=='PAL' && split.svBase!=null) baseCop=split.svBase;
  if(fam==='PAL' && split.mfBase!=null) baseCop=split.mfBase;
  parts.push({code:baseCode,copay:baseCop,chargeback:baseCB,profit:baseCop-baseCB});

  const addonCount=partsCodes.length-1;
  let addonCopays=[]; let explicitAdd=(fam!=='PAL')?split.svAdd:split.mfAdd;
  if(explicitAdd!=null){ addonCopays=[explicitAdd,...Array(Math.max(0,addonCount-1)).fill(0)]; }
  else if(compositeCopayNums.length>=partsCodes.length){ addonCopays=compositeCopayNums.slice(1); }
  else { const remaining=Math.max(compositeTotalCopay-baseCop,0);
         if(addonCount<=1){ addonCopays=[remaining]; } else { const each=remaining/addonCount; addonCopays=Array.from({length:addonCount},()=>each); } }
  const addonCBEach=addonCount<=1?compositeAddOnCB:(compositeAddOnCB/addonCount);
  for(let i=1;i<partsCodes.length;i++){
    const code=partsCodes[i]; const cop=num(addonCopays[i-1]??0); const cb=addonCBEach;
    parts.push({code,copay:cop,chargeback:cb,profit:cop-cb});
  }
  const totalCop=parts.reduce((a,x)=>a+x.copay,0);
  const totalCB =parts.reduce((a,x)=>a+x.chargeback,0);
  return {name:desc,code:codeStr,copay:totalCop,chargeback:totalCB,profit:totalCop-totalCB,parts};
}
function makeBundle(base,addOns){
  const rows=[base,...addOns.filter(Boolean)];
  const lines=rows.map(parseLine);
  const cop=sum(lines.map(x=>x.copay));
  const cb =sum(lines.map(x=>x.chargeback));
  const pr =cop-cb;
  const label=base.enhancement||base.subtype||base.code||'Base';
  return {label,lines,copay:cop,chargeback:cb,profit:pr,ratio:cop?pr/cop:0};
}
function computeBundles(){
  if(!DATA.length){ el('stack').innerHTML=''; return; }
  const fam=el('lensFamily').value;
  const wantAR=el('includeAR').checked;
  const wantAsp=el('includeAspheric').checked;
  const wantOS =el('includeOversize').checked;
  const wantGlass=el('includeGlass').checked;
  const tintSel=el('lensTint').value;

  const isCustomMeasure=row=>/custom\s*measure/i.test(N(row?.enhancement||row?.subtype||''));
  const isAA=row=>splitCodes(row.code)[0]==='AA';
  function isAsphericRow(row){
    const name=N(row.enhancement||row.subtype||'');
    const first=splitCodes(row.code)[0]||'';
    const looks=/aspheric/.test(name)||/^BA\b/.test(first);
    return looks && !isAA(row);
  }

  let base=[];
  if(fam==='PAL'){
    base=byKey('progressive_level').filter(r=>applies(r,fam)).filter(r=>{
      const name=N(r.enhancement);
      if(wantGlass && !isGlassName(name)) return false;
      if(!wantGlass && isGlassName(name)) return false;
      if(/custom\s*measure/i.test(name)) return false;
      if(tintSel==='polarized') return /polariz/.test(name);
      return !/(photochrom|polariz|tint|tinted|sunglass|gradient|color|colored)/.test(name);
    });
    if(!wantGlass){
      const kaRow=pickBaseByExactCode('KA');
      if(kaRow && !base.some(r=>splitCodes(r.code)[0]==='KA')) base.push(kaRow);
    }
  } else {
    if(tintSel==='polarized'){
      base = byKey('sun_tech').filter(r=>applies(r,fam) && /polariz/.test(N(r.enhancement)))
                               .filter(r=> wantGlass ? /glass/.test(N(r.enhancement)) : !/glass/.test(N(r.enhancement)));
    } else {
      let pool=(fam==='SV'?byKey('base_material'):byKey('occupational'));
      pool=pool.filter(r=>{
        const name=N(r.enhancement);
        if(wantGlass && !isGlassName(name)) return false;
        if(!wantGlass && isGlassName(name)) return false;
        return true;
      });
      pool=pool.filter(r=>{
        const name=N(r.enhancement);
        if(/photochrom|polariz|tint|tinted|sunglass|gradient|color|colored/.test(name)) return false;
        if(wantGlass) return true;
        const asph=isAsphericRow(r);
        return wantAsp?asph:!asph;
      });
      if(!wantGlass && !wantAsp && fam==='SV' && tintSel==='clear'){
        const aaRow=pickBaseByExactCode('AA');
        if(aaRow){ const notAA=pool.filter(r=>splitCodes(r.code)[0]!=='AA'); pool=[aaRow,...notAA]; }
      }
      base=pool;
    }
  }

  function rankAR(ars){
    const gradeVal=s=>{ const m=String(s||'').match(/\b([A-D])\b/i); if(!m) return null; return {A:1,B:2,C:3,D:4}[m[1].toUpperCase()]||null; };
    return [...ars].sort((a,b)=>{
      const ga=gradeVal(a.enhancement)||-1, gb=gradeVal(b.enhancement)||-1;
      if(ga!==gb) return gb-ga;
      const pa=num(a.copay)-num(a.chargeback), pb=num(b.copay)-num(b.chargeback);
      return pb-pa;
    });
  }
  const arPool = (wantAR ? byKey('ar_level').filter(r=>{
    const name=N(r.enhancement);
    if(wantGlass && !isGlassName(name)) return false;
    return applies(r,fam);
  }) : []);
  const arRanked=(wantAR && arPool.length)?rankAR(arPool):[];
  const arOptions=(wantAR && arRanked.length)?arRanked:[null];

  const overs = wantOS ? (byKey('oversize').filter(r=>applies(r,fam))[0]||null) : null;

  function buildBundle(m,arRow){
    const cm=(el('includeCM')?.checked && fam==='PAL') ? (DATA.filter(r=>applies(r,'PAL')).find(row=>/custom\s*measure/i.test(N(row.enhancement||row.subtype||'')))||null) : null;
    return makeBundle(m,[arRow,chooseSunFor(m),cm,overs]);
  }

  const all=[];
  for(const m of base){ for(const ar of arOptions){ all.push(buildBundle(m,ar)); } }
  if(!all.length){ renderStack([{name:'Best',cls:'best',b:null},{name:'Better',cls:'better',b:null},{name:'Good',cls:'good',b:null},{name:'Cheapest',cls:'good',b:null}]); return; }

  const MaxPrice=Math.max(...all.map(b=>b.copay));
  const best = all.reduce((p,c)=>(!p||c.profit>p.profit||(c.profit===p.profit&&c.copay<p.copay)?c:p),null);
  function pickUnderCap(cap){
    const cand=all.filter(b=>b.copay<=cap);
    if(cand.length){ return cand.reduce((p,c)=>(!p||c.profit>p.profit||(c.profit===p.profit&&c.copay<p.copay)?c:p),null); }
    const looser=cap/CAP_RELAX_FACTOR;
    const cand2=all.filter(b=>b.copay<=looser);
    if(cand2.length){ return cand2.reduce((p,c)=>(!p||c.profit>p.profit||(c.profit===p.profit&&c.copay<p.copay)?c:p),null); }
    return all.reduce((p,c)=>(!p||c.copay<p.copay||(c.copay===p.copay&&c.profit>p.profit)?c:p),null);
  }
  const better=pickUnderCap(MaxPrice*BETTER_CAP_OF_MAX);
  const good  =pickUnderCap(MaxPrice*GOOD_CAP_OF_MAX);
  const cheapest=all.reduce((p,c)=>(!p||c.copay<p.copay||(c.copay===p.copay&&c.profit>p.profit)?c:p),null);

  const picks=[best,better,good,cheapest].filter(Boolean);
  const uniq=[], seen=new Set();
  for(const b of picks){
    const sig=[b.label,b.copay.toFixed(2),b.chargeback.toFixed(2),b.profit.toFixed(2)].join('|');
    if(!seen.has(sig)){ seen.add(sig); uniq.push(b); }
  }

  renderStack([
    {name:'Best',cls:'best',b:uniq[0]||null},
    {name:'Better',cls:'better',b:uniq[1]||null},
    {name:'Good',cls:'good',b:uniq[2]||null},
    {name:'Cheapest',cls:'good',b:uniq[3]||null},
  ]);
}
const tdMoney = (v, key) => `<td class="cell-money" data-key="${key}" data-anim="${v.toFixed(2)}">$${v.toFixed(2)}</td>`;
function breakdownDetails(li,rowKey){
  if(!li.parts?.length) return '';
  const rows = li.parts.map((p,pi) => `
    <div></div>
    <div class="money"><span class="codepill" title="${p.code}">${p.code}</span></div>
    <div class="money" data-key="${rowKey}-p${pi}-c"  data-anim="${p.copay.toFixed(2)}">$${p.copay.toFixed(2)}</div>
    <div class="money" data-key="${rowKey}-p${pi}-pr" data-anim="${p.profit.toFixed(2)}">$${p.profit.toFixed(2)}</div>
  `).join('');
  return `
    <tr>
      <td colspan="4" style="padding:0;border:0">
        <details class="break" open>
          <summary>Breakdown</summary>
          <div class="breakbox">
            <div class="align-grid">
              <div></div><div class="hdr">Code</div><div class="hdr">Copay</div><div class="hdr">Service Fee</div>
              ${rows}
            </div>
          </div>
        </details>
      </td>
    </tr>`;
}
function renderTier({name,cls,b}){
  const div=document.createElement('div'); div.className='tier';
  if(!b){
    div.innerHTML=`<div class="tierHead"><div class="stars ${cls}">
      <span>${name==='Best'?'★★★':name==='Better'?'★★':name==='Good'?'★':'◎'}</span>
      <span class="sub" style="margin-left:8px">${name}</span></div>
      <div class="figures"><div class="hero">—</div><div class="caption">Patient Copay</div></div></div>
      <div class="sub">No viable bundle</div>`; return div;
  }
  const stars=name==='Best'?'★★★':name==='Better'?'★★':name==='Good'?'★':'◎';
  const head=`<div class="tierHead">
    <div class="stars ${cls}"><div title="${name}" style="font-size:18px">${stars}</div><span class="sub" style="margin-left:6px">${b.label}</span></div>
    <div class="figures">
      <div class="hero" aria-label="Patient Copay" data-key="${name}-hero" data-anim="${b.copay.toFixed(2)}">$${b.copay.toFixed(2)}</div>
      <div class="caption">Patient Copay</div>
      <div class="caption">Service Fee (Practice Profit): <span class="svc" data-key="${name}-profit" data-anim="${b.profit.toFixed(2)}">$${b.profit.toFixed(2)}</span></div>
    </div>
  </div>`;
  const lines=b.lines.map((li,i)=>{
    const rowKey=`${name}-line${i}`;
    const main=`<tr>
      <td class="cell-item"><span class="label" title="${li.name}">${li.name}</span></td>
      <td class="cell-code" title="${li.code||''}">${li.code||'—'}</td>
      ${tdMoney(li.copay,  `${rowKey}-c`)}
      ${tdMoney(li.profit, `${rowKey}-pr`)}
    </tr>`;
    const parts=(li.parts&&li.parts.length)?breakdownDetails(li,rowKey):'';
    return main+parts;
  }).join('');
  div.innerHTML=head+`<table class="bundle">
    <colgroup><col><col><col><col></colgroup>
    <thead><tr><th>Item</th><th>Code</th><th>Copay</th><th>Service Fee</th></tr></thead>
    <tbody>${lines}</tbody>
    <tfoot><tr><th colspan="2" style="text-align:right">Totals</th>
      ${tdMoney(b.copay,`${name}-tot-c`)}${tdMoney(b.profit,`${name}-tot-pr`)}
    </tr></tfoot></table>`;
  return div;
}
function renderStack(rows){
  const stack=el('stack'); stack.innerHTML='';
  rows.forEach(r=>stack.appendChild(renderTier(r)));
  fitHeroText(); fitViewportScale(); animateMoney(420);
}
function fitViewportScale() {
  const frame = document.getElementById('frame'); if (!frame) return;
  const vw = document.documentElement.clientWidth;
  if (vw <= 900){ frame.style.transform = 'none'; frame.style.width = '100%'; return; }
  const needed = 360*4 + 14*3; let scale = Math.min(1, vw / needed); if (scale < 0.82) scale = 0.82;
  frame.style.transform = `scale(${scale})`; frame.style.width = (100 / scale) + '%';
}
function fitHeroText() {
  document.querySelectorAll('.hero').forEach(n => {
    const parent = n.parentElement; if(!parent) return;
    n.style.fontSize = ''; const maxPx = parseFloat(getComputedStyle(n).fontSize) || 30;
    let size = maxPx; const fits = () => n.scrollWidth <= parent.clientWidth;
    while (size > 14 && !fits()) { size -= 0.4; n.style.fontSize = size + 'px'; }
  });
}
function animateMoney(duration = 350) {
  const nodes = [...document.querySelectorAll('[data-anim]')];
  const frames = [];
  const LAST = window.__LAST_NUMS__ || (window.__LAST_NUMS__ = new Map());
  nodes.forEach(n => {
    const key = n.getAttribute('data-key') || Math.random().toString(36).slice(2);
    const toVal = parseFloat(n.getAttribute('data-anim')) || 0;
    const fromVal = LAST.has(key) ? LAST.get(key) : (parseFloat(n.textContent.replace(/[^0-9.-]/g,'')) || 0);
    LAST.set(key, toVal);
    frames.push({ n, fromVal, toVal });
  });
  const start = performance.now();
  (function step(ts){
    const t = Math.min(1, (ts - start) / duration);
    const k = 1 - Math.pow(1 - t, 3);
    frames.forEach(({ n, fromVal, toVal }) => {
      const v = fromVal + (toVal - fromVal) * k;
      n.textContent = '$' + v.toFixed(2);
    });
    if (t < 1) requestAnimationFrame(step);
  })(start);
}
const ro = new ResizeObserver(()=>{ fitHeroText(); fitViewportScale(); });
ro.observe(document.body);

/* ---------- controls ---------- */
el('forceRefresh').onclick=()=>{ clearCacheStorage(); loadCSV(); };
el('clearCache').onclick =()=>{ clearCacheStorage(); el('status').textContent=' cache cleared — click Force Refresh to reload'; };
['lensFamily','lensTint','includeAR','includeAspheric','includeOversize','includeGlass','includeCM']
  .forEach(id=>{ const n=el(id); if(n) n.onchange=computeBundles; });

/* ===================== OCR section (with PDF + HEIC support) ===================== */
const scanBtn   = document.getElementById('scanBenefitsBtn');
const scanInput = document.getElementById('scanBenefitsFile');
scanBtn?.addEventListener('click', ()=> scanInput?.click());
scanInput?.addEventListener('change', async ()=>{
  const file = scanInput.files?.[0]; if(!file) return;
  try{
    setStatus('preparing…');
    scanBtn.disabled = true;

    let canvas;
    if (/pdf$/i.test(file.name) || file.type === 'application/pdf') {
      setStatus('rendering PDF…');
      canvas = await pdfFirstPageToCanvas(file);
    } else {
      setStatus('loading image…');
      canvas = await fileToCanvas(file);
    }

    // Preprocess: scale up + binarize + sharpen
    setStatus('cleaning image…');
    const prep1 = preprocess(canvas, {scale:1.8, grayscale:true, threshold:'otsu', unsharp:true});
    const prep2 = preprocess(canvas, {scale:1.4, grayscale:true, threshold:'sauvola', unsharp:true});

    // Two OCR passes
    setStatus('reading (pass 1/2)…');
    const t1 = await runTess(prep1, { psm: 6 });
    setStatus('reading (pass 2/2)…');
    const t2 = await runTess(prep2, { psm: 4 });

    let text = chooseBestText(t1, t2);
    if(!text || !text.trim()){
      // final fallback: raw (no preprocessing), PSM 3
      setStatus('retrying with fallback…');
      const t3 = await runTess(canvas, { psm: 3 });
      text = t3 || '';
    }

    el('ocrText').textContent = text || '—';
    if(!text.trim()){
      setStatus('no text detected — try clearer photo');
      alert('I couldn’t find readable text. Try: fill the frame, even lighting, no glare, and keep the phone parallel to the page.');
      return;
    }

    setStatus('parsing benefits…');
    const benefits = parseBenefitsSmart(text);
    window.lastBenefits = benefits;
    paintKV(benefits);

    alert([
      `Frame Allowance: ${fmt(benefits.frameAllowance)}`,
      `Exam Copay: ${fmt(benefits.examCopay)}`,
      `PAL (Progressive) Copay: ${fmt(benefits.progressiveCopay)}`,
      `AR: ${benefits.arTier ? 'Tier '+benefits.arTier : fmt(benefits.arCopay)}`,
      `Photochromic: ${fmt(benefits.photochromicCopay)}`,
      `Polarized: ${fmt(benefits.polarizedCopay)}`
    ].join('\n'));

    setStatus('scan complete');
  }catch(e){
    console.error(e);
    setStatus('scan failed');
    alert('Scan failed. Likely causes: unsupported file format or blocked camera/photo access. Try another photo or export the PDF and retry.');
  }finally{
    scanBtn.disabled = false;
    scanInput.value='';
  }
});

function setStatus(s){ const n=el('status'); if(n) n.textContent=s; }

/* ---- File -> canvas helpers ---- */
async function pdfFirstPageToCanvas(file){
  const buf = await file.arrayBuffer();
  const pdf = await pdfjsLib.getDocument({data:buf}).promise;
  const page = await pdf.getPage(1);
  const viewport = page.getViewport({scale:2.0});
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  canvas.width = viewport.width; canvas.height = viewport.height;
  await page.render({canvasContext:ctx, viewport}).promise;
  return canvas;
}
function fileToCanvas(file){
  return new Promise((resolve,reject)=>{
    const url = URL.createObjectURL(file);
    const img = new Image();
    img.onload = async ()=> {
      try{
        const canvas = document.createElement('canvas');
        canvas.width = img.naturalWidth; canvas.height = img.naturalHeight;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(img, 0, 0);
        URL.revokeObjectURL(url);
        resolve(canvas);
      }catch(err){
        // Fallback path (e.g., HEIC or decode issues): use createImageBitmap
        try{
          URL.revokeObjectURL(url);
          createImageBitmap(file).then(bitmap=>{
            const canvas = document.createElement('canvas');
            canvas.width = bitmap.width; canvas.height = bitmap.height;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(bitmap,0,0);
            resolve(canvas);
          }, reject);
        }catch(e2){ reject(e2); }
      }
    };
    img.onerror = ()=> {
      // If <img> fails (e.g., HEIC), try createImageBitmap directly
      createImageBitmap(file).then(bitmap=>{
        const canvas = document.createElement('canvas');
        canvas.width = bitmap.width; canvas.height = bitmap.height;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(bitmap,0,0);
        URL.revokeObjectURL(url);
        resolve(canvas);
      }).catch(reject);
    };
    img.src = url;
  });
}

/* ---- Preprocess + OCR ---- */
function preprocess(sourceCanvas, {scale=2, grayscale=true, threshold='otsu', unsharp=true}={}){
  const w = Math.round(sourceCanvas.width * scale);
  const h = Math.round(sourceCanvas.height * scale);
  const canvas = document.createElement('canvas');
  canvas.width = w; canvas.height = h;
  const ctx = canvas.getContext('2d');
  ctx.drawImage(sourceCanvas, 0, 0, w, h);

  let imgData = ctx.getImageData(0,0,w,h);
  const d = imgData.data;

  if(grayscale){
    for(let i=0;i<d.length;i+=4){
      const y = 0.299*d[i] + 0.587*d[i+1] + 0.114*d[i+2];
      d[i]=d[i+1]=d[i+2]=y;
    }
  }
  if(unsharp){
    const blurred = boxBlur(imgData, w, h, 1);
    for(let i=0;i<d.length;i+=4){
      const hp = d[i] - blurred.data[i];
      const v = clamp(d[i] + hp*0.8);
      d[i]=d[i+1]=d[i+2]=v;
    }
  }
  if(threshold){
    if(threshold==='otsu'){
      const t = otsuThreshold(imgData);
      for(let i=0;i<d.length;i+=4){
        const v = d[i] >= t ? 255:0;
        d[i]=d[i+1]=d[i+2]=v;
      }
    } else if(threshold==='sauvola'){
      const win=25, k=0.3;
      const g = new Uint8ClampedArray(d.length/4);
      for(let i=0,pi=0;i<d.length;i+=4,pi++) g[pi]=d[i];
      const mean = boxBlurGray(g, w, h, Math.floor(win/2));
      const std  = localStd(g, mean, w, h, Math.floor(win/2));
      for(let y=0;y<h;y++){
        for(let x=0;x<w;x++){
          const i = y*w+x;
          const m = mean[i], s = std[i];
          const T = m*(1 + k*((s/128)-1));
          const v = g[i] > T ? 255:0;
          const di = i*4;
          d[di]=d[di+1]=d[di+2]=v; d[di+3]=255;
        }
      }
    }
  }

  ctx.putImageData(imgData,0,0);
  return canvas;
}
function clamp(v){ return v<0?0:v>255?255:v; }
function boxBlur(imgData, w, h, r){
  const out = new ImageData(w,h);
  const src = imgData.data, dst = out.data;
  const tmp = new Uint32Array(w*h);
  // horizontal
  for(let y=0;y<h;y++){
    let sum=0;
    for(let x=0;x<w+r;x++){
      if(x<w){ sum += src[(y*w+x)*4]; }
      if(x>=r){ const xi=x-r; tmp[y*w+xi]=sum/(Math.min(x+1,w)-Math.max(0,x-r)); }
      if(x>=2*r+1){ sum -= src[(y*w+(x-2*r-1))*4]; }
    }
  }
  // vertical
  for(let x=0;x<w;x++){
    let sum=0;
    for(let y=0;y<h+r;y++){
      if(y<h){ sum += tmp[y*w+x]; }
      if(y>=r){
        const yi=y-r;
        const val = sum/(Math.min(y+1,h)-Math.max(0,y-r));
        const di=(yi*w+x)*4;
        dst[di]=dst[di+1]=dst[di+2]=val; dst[di+3]=255;
      }
      if(y>=2*r+1){ sum -= tmp[(y-2*r-1)*w+x]; }
    }
  }
  return out;
}
function boxBlurGray(g, w, h, r){
  const out = new Uint8ClampedArray(w*h);
  const tmp = new Float32Array(w*h);
  for(let y=0;y<h;y++){
    let sum=0;
    for(let x=0;x<w+r;x++){
      if(x<w) sum += g[y*w+x];
      if(x>=r){ const xi=x-r; tmp[y*w+xi]=sum/(Math.min(x+1,w)-Math.max(0,x-r)); }
      if(x>=2*r+1) sum -= g[y*w+(x-2*r-1)];
    }
  }
  for(let x=0;x<w;x++){
    let sum=0;
    for(let y=0;y<h+r;y++){
      if(y<h) sum += tmp[y*w+x];
      if(y>=r){
        const yi=y-r;
        out[yi*w+x]=sum/(Math.min(y+1,h)-Math.max(0,y-r));
      }
      if(y>=2*r+1) sum -= tmp[(y-2*r-1)*w+x];
    }
  }
  return out;
}
function localStd(g, mean, w, h, r){
  const out = new Uint8ClampedArray(w*h);
  const sq = new Uint32Array(w*h);
  for(let i=0;i<g.length;i++) sq[i]=g[i]*g[i];
  const meanSq = boxBlurGray(sq, w, h, r);
  for(let i=0;i<g.length;i++){
    const v = Math.sqrt(Math.max(0, meanSq[i]-mean[i]*mean[i]));
    out[i]=v;
  }
  return out;
}
function otsuThreshold(imgData){
  const hist=new Array(256).fill(0);
  const d=imgData.data;
  for(let i=0;i<d.length;i+=4) hist[d[i]]++;
  const total = d.length/4;
  let sum=0; for(let i=0;i<256;i++) sum += i*hist[i];
  let sumB=0, wB=0, wF=0, varMax=0, t=127;
  for(let i=0;i<256;i++){
    wB += hist[i]; if(wB===0) continue;
    wF = total - wB; if(wF===0) break;
    sumB += i*hist[i];
    const mB = sumB / wB;
    const mF = (sum - sumB) / wF;
    const v = wB*wF*(mB-mF)*(mB-mF);
    if(v>varMax){ varMax=v; t=i; }
  }
  return t;
}
async function runTess(canvas, {psm=6}={}){
  // Use canvas directly; add a small whitelist and a logger for debugging
  const opts = {
    logger: m => { /* uncomment to debug: console.log(m); */ },
    tessedit_pageseg_mode: String(psm),
    tessedit_char_whitelist: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789$.,:-/() '
  };
  const out = await Tesseract.recognize(canvas, 'eng', opts);
  return (out && out.data && out.data.text) ? out.data.text : '';
}
function chooseBestText(a,b){
  const score = t => ((t.match(/\$/g)||[]).length*3) + (t.length/500) - ((t.match(/\b[Iil]\b/g)||[]).length);
  return score(a)>=score(b)?a:b;
}

/* ---- Parsing ---- */
function centsOf(s){ if(!s) return null; const m=String(s).replace(/[^\d.]/g,''); if(!m) return null; const [a,b='0']=m.split('.'); return parseInt(a||'0',10)*100+parseInt((b+'00').slice(0,2),10); }
function money(c){ if(c==null) return null; return {cents:c,raw:`$${(c/100).toFixed(2)}`}; }
function fmt(m){ return m?.raw || '—'; }

function parseBenefitsSmart(raw){
  const text = (raw||'').replace(/\r/g,'');
  const lines = text.split('\n').map(s=>s.trim()).filter(Boolean);

  const pickMoneyNear = (keywords, fallbackRegex=/\$\s*\d[\d,]*(?:\.\d{2})?/g) =>{
    let best=null, bestScore=-1;
    for(const line of lines){
      const l=line.toLowerCase();
      const kwScore = keywords.reduce((acc,k)=> acc + (l.includes(k)?1:0), 0);
      if(!kwScore) continue;
      const m = line.match(fallbackRegex);
      if(m && m.length){
        const val = m[m.length-1];
        const c = centsOf(val);
        const score = kwScore*10 + 2;
        if(c!=null && score>bestScore){ best = c; bestScore = score; }
      } else if(/included|covered|no cost|\$0/i.test(line)){
        const score = kwScore*10 + 1;
        if(score>bestScore){ best = 0; bestScore = score; }
      }
    }
    return best!=null ? money(best) : null;
  };

  let arTier = null;
  for(const line of lines){
    const m = /(?:anti[\s-]*reflective|\bAR\b)[^\n]{0,24}(?:tier|level)\s*([ABCD])/i.exec(line);
    if(m){ arTier = m[1].toUpperCase(); break; }
  }
  const arCopay = arTier ? null : pickMoneyNear(['anti-reflective','antireflective',' ar ']);

  const benefits = {
    source: 'VSP',
    frameAllowance: pickMoneyNear(['frame','allowance']),
    examCopay:      pickMoneyNear(['exam','copay']),
    svLensCopay:    pickMoneyNear(['single vision','sv']),
    progressiveCopay: pickMoneyNear(['progressive','pal']),
    arTier,
    arCopay,
    photochromicCopay: pickMoneyNear(['photochrom','transitions']),
    polarizedCopay:    pickMoneyNear(['polariz']),
    rawText: raw
  };
  return benefits;
}
function paintKV(b){
  el('kv_frame').textContent = fmt(b.frameAllowance);
  el('kv_exam').textContent  = fmt(b.examCopay);
  el('kv_sv').textContent    = fmt(b.svLensCopay);
  el('kv_pal').textContent   = fmt(b.progressiveCopay);
  el('kv_ar').textContent    = b.arTier ? ('Tier '+b.arTier) : fmt(b.arCopay);
  el('kv_photo').textContent = fmt(b.photochromicCopay);
  el('kv_polar').textContent = fmt(b.polarizedCopay);
}

/* ---------- boot ---------- */
(function boot(){ loadCSV(); })();

} // guard
</script>
</body>
</html>
