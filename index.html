<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>PayerEdge — VSP Bundles</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">

  <style>
    :root{
      --bg:#090e16; --bg-elev:#0c1320; --fg:#eaf1ff; --muted:#9fb0c9; --line:#263448;
      --accent:#72a8ff; --accent-2:#7be0c3;
      --tier-best:#ffd166; --tier-better:#a9c2ff; --tier-good:#7be0c3;
      --shadow-lg:0 18px 40px rgba(0,0,0,.35); --shadow-md:0 10px 26px rgba(0,0,0,.28);
      --radius:18px; --radius-sm:12px;
      --fz-12:12px; --fz-13:13px; --fz-15:15px; --fz-18:18px; --fz-20:20px; --fz-36:36px;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      background:
        radial-gradient(1200px 600px at 20% -10%, rgba(90,168,255,.12), transparent 60%),
        radial-gradient(900px 500px at 110% 10%, rgba(123,224,195,.10), transparent 60%),
        var(--bg);
      color:var(--fg);
      font:var(--fz-15)/1.45 Inter, system-ui, -apple-system, "Segoe UI", Roboto, sans-serif;
      -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale;
      font-variant-numeric: tabular-nums;
    }

    header{
      position:sticky; top:0; z-index:20; display:flex; justify-content:space-between; align-items:center; gap:14px;
      padding:16px 20px; background:linear-gradient(180deg, rgba(9,14,22,.95), rgba(9,14,22,.78));
      border-bottom:1px solid var(--line); backdrop-filter: blur(10px);
    }
    h1{margin:0; font-weight:800; font-size:var(--fz-20); letter-spacing:.2px}
    .sub{color:var(--muted); font-size:var(--fz-12)}
    .version{color:var(--muted)}
    main{padding:18px}

    .bar{
      display:flex; align-items:center; flex-wrap:wrap; gap:10px 14px;
      background:linear-gradient(180deg, var(--bg-elev), #0b1220);
      border:1px solid var(--line); border-radius:var(--radius); padding:12px 12px;
      box-shadow: var(--shadow-md);
    }
    .group{display:flex; gap:10px; align-items:center; padding:6px 10px; border-radius:999px; background:#0b1424}
    .btn{ background:#121f35; border:1px solid var(--line); color:var(--fg); padding:8px 12px; border-radius:var(--radius-sm); cursor:pointer; font-weight:600; transition:.15s }
    .btn:hover{ background:#162844; border-color:#2e4260 }
    .switch{display:inline-flex; align-items:center; gap:8px}
    .switch select, .switch input[type="checkbox"]{ accent-color:var(--accent) }
    select{ background:#0e1a30; color:var(--fg); border:1px solid var(--line); border-radius:10px; padding:6px 8px; outline:none }
    select:focus{ box-shadow:0 0 0 3px rgba(114,168,255,.25) }
    #status{ margin-left:auto; padding:6px 10px; border-radius:999px; border:1px dashed var(--line); background:#0b1422; color:#c7d6ef }

    .stack{ display:grid; gap:18px; grid-template-columns:repeat(auto-fit, minmax(320px,1fr)); align-items:stretch; margin-top:16px }
    .tier{ background:linear-gradient(180deg, #0f1726, #0c1422); border:1px solid var(--line); border-radius:var(--radius); box-shadow: var(--shadow-lg); padding:16px; transition:.25s }
    .tierHead{display:grid; grid-template-columns:1fr auto; align-items:center; gap:10px; margin-bottom:12px}
    .stars{font-weight:800; display:flex; align-items:center; gap:8px}
    .stars .tag{font-size:var(--fz-12); color:var(--muted); padding:2px 8px; border:1px solid var(--line); border-radius:999px; background:#0c1424}
    .stars.best{color:var(--tier-best)} .stars.better{color:var(--tier-better)} .stars.good{color:var(--tier-good)}

    .figures{ text-align:right; display:grid; gap:2px }
    .hero{ font-size:var(--fz-36); font-weight:800; line-height:1.0; letter-spacing:.2px; color:#cfe6ff; text-shadow: 0 6px 18px rgba(114,168,255,.18) }
    .caption{ color:var(--muted); font-size:var(--fz-12) }
    .svc{ font-weight:800; color:var(--accent-2) }

    table{width:100%; border-collapse:collapse; margin-top:12px}
    th,td{border-bottom:1px dashed #203043; padding:9px 6px; text-align:left; font-size:var(--fz-13)}
    th{color:var(--muted); font-weight:700}
    .code{font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size:12px; color:#cfe1ff}
    .money{font-weight:800}
    .nowrap{white-space:nowrap}

    .break{ margin:6px 0 10px; background:#0b1424; border:1px solid var(--line); border-radius:10px; }
    .break table{ width:100%; border-collapse:collapse; }
    .break th,.break td{ border:0; padding:6px 8px; text-align:left; font-size:12px; }
    .break .codepill{ display:inline-block; padding:2px 8px; border:1px solid var(--line); border-radius:999px; font-family:ui-monospace,Menlo,Consolas,monospace; font-size:12px; color:#cfe1ff; background:#0e1a30; }
    .break .colhed{ color:var(--muted); font-weight:600; }

    :focus-visible{ outline:2px solid var(--accent); outline-offset:2px; border-radius:8px }
    @media print{ header,.bar{display:none} body{background:#fff; color:#000} .tier{break-inside:avoid; border:1px solid #000; box-shadow:none} table, th, td{border-color:#000} }
  </style>
</head>
<body>
  <header>
    <div>
      <h1>PayerEdge — VSP Bundles</h1>
      <div class="sub">Scoreboard shows <b>patient copay</b> and <b>service fee</b> (Copay − Holdback). Sun choices are exclusive.</div>
    </div>
    <div class="version sub" id="version">loading…</div>
  </header>

  <main>
    <div class="bar" role="toolbar" aria-label="Bundle controls">
      <div class="group">
        <button class="btn" id="forceRefresh" title="Reload CSV and recompute">Force Refresh</button>
        <button class="btn" id="clearCache" title="Clear local CSV cache">Clear Cache</button>
      </div>
      <div class="group">
        <label class="switch">Lens family
          <select id="lensFamily" aria-label="Lens family">
            <option value="SV" selected>Single Vision</option>
            <option value="LINED">Lined Bi/Tri</option>
            <option value="PAL">Progressive</option>
          </select>
        </label>
        <label class="switch">Lens tint
          <select id="lensTint" aria-label="Lens tint">
            <option value="clear" selected>Clear</option>
            <option value="tinted">Tinted</option>
            <option value="polarized">Polarized</option>
            <option value="transitions">Transitions®</option>
          </select>
        </label>
      </div>
      <div class="group">
        <label class="switch"><input type="checkbox" id="includeAR" checked> Include AR (tiered)</label>
        <label class="switch"><input type="checkbox" id="includeAspheric"> Aspheric</label>
        <label class="switch"><input type="checkbox" id="includeOversize"> Oversize</label>
        <label class="switch"><input type="checkbox" id="includeGlass"> Glass</label>
        <label class="switch"><input type="checkbox" id="includeCM"> Custom measurements (N/O only)</label>
      </div>
      <span id="status" aria-live="polite"></span>
    </div>

    <div id="stack" class="stack"></div>
  </main>

  <script>
  (function(){
    /* ================== Config ================== */
    const CSV_PATH = './data/vsp_choice_master_v9_strict.csv'; // strict schema (see bottom)
    const CACHE_KEY='vsp-v9-1-text';
    const META_KEY='vsp-v9-1-meta';
    const BA_HOLDBACK_DEFAULT = { SV:24, MF:34 }; // used only if BA row missing

    const BETTER_CAP_OF_MAX = 0.75; // ≤75% of max copay
    const GOOD_CAP_OF_MAX   = 0.50; // ≤50% of max copay
    const CAP_RELAX_FACTOR  = 0.90; // fallback relaxer

    /* ================== Utils ================== */
    const $ = id => document.getElementById(id);
    const money = n => '$'+Number(n||0).toFixed(2);
    const num = v => { const x=parseFloat(String(v??'').replace(/[^0-9.-]/g,'')); return isFinite(x)?x:0; };

    function parseCSV(text){
      const rows=[]; let row=[], field='', q=false;
      for(let i=0;i<text.length;i++){
        const ch=text[i];
        if(ch==='\"'){ if(q && text[i+1]==='\"'){ field+='\"'; i++; } else { q=!q; } continue; }
        if(!q && ch===','){ row.push(field); field=''; continue; }
        if(!q && (ch==='\n' || ch==='\r')){ if(field!==''||row.length){ row.push(field); rows.push(row); row=[]; field=''; } continue; }
        field+=ch;
      }
      if(field!==''||row.length){ row.push(field); rows.push(row); }
      const headers = rows.shift().map(h=>h.replace(/^\"|\"$/g,'').trim());
      return rows.filter(r=>r.length>=headers.length).map(r=>{
        const o={}; headers.forEach((h,i)=>o[h]=(r[i]||'').replace(/^\"|\"$/g,'').trim()); return o;
      });
    }

    function setCache(text,meta){ localStorage.setItem(CACHE_KEY,text); localStorage.setItem(META_KEY,JSON.stringify(meta)); }
    function getCache(){ return { text: localStorage.getItem(CACHE_KEY), meta: JSON.parse(localStorage.getItem(META_KEY)||'{}') }; }
    function clearCache(){ localStorage.removeItem(CACHE_KEY); localStorage.removeItem(META_KEY); }

    function famSegFromUI(){
      const fam = $('lensFamily').value; // SV | LINED | PAL
      if (fam==='SV')     return {family:'SV', segment:'SV'};
      if (fam==='PAL')    return {family:'MF', segment:'Prog'};
      if (fam==='LINED')  return {family:'MF', segment:'Bifocal'};
      return {family:'SV', segment:'SV'};
    }

    function normRow(r){
      const n=(k)=>num(r[k]);
      return {
        plan: (r.plan||'').trim(),
        kind: (r.kind||'').toLowerCase(),           // pair | base | addon
        code: (r.code||'').toUpperCase(),
        item: r.item||'',
        family: (r.family||'BOTH').toUpperCase(),    // SV | MF | BOTH
        material_level: r.material_level||'—',       // Hi67 | Mid | Poly | CR
        sun: r.sun||'—',
        exclusive_group: r.exclusive_group||'',
        requires_flags: String(r.requires_flags||'').toLowerCase().split(/\s*,\s*/).filter(Boolean),
        forbids_flags: String(r.forbids_flags||'').toLowerCase().split(/\s*,\s*/).filter(Boolean),
        applies_to: (r.applies_to||'all').toLowerCase(),
        pair_with: (r.pair_with||'').toUpperCase(),
        copay_sv: n('copay_sv'),
        holdback_sv: n('holdback_sv'),
        copay_mf: n('copay_mf'),
        holdback_mf: n('holdback_mf'),
        notes: r.notes||'',
        segment: (r.segment||'Any'),
        pair_components: (r.pair_components||'').toUpperCase()
      };
    }

    function familyVals(row, fam){
      return (fam==='SV')
        ? {copay: row.copay_sv||0, hold: row.holdback_sv||0}
        : {copay: row.copay_mf||0, hold: row.holdback_mf||0};
    }

    /* ================== Load CSV ================== */
    let ALL = []; // normalized rows for this plan

    async function loadCSV(){
      const status=$('status'); status.textContent=' loading…';

      try{
        const res = await fetch(CSV_PATH, {cache:'no-store'});
        if(!res.ok) throw new Error('HTTP '+res.status);
        const text = await res.text();
        const raw = parseCSV(text);
        const rows = raw.map(normRow).filter(r=>!r.plan || r.plan==='VSP_choice');
        ALL = rows;
        setCache(text, {plan:'VSP_choice', source:'network', version:'v15'});
        $('version').textContent = `plan=VSP_choice • rows=${rows.length} • version=v15 • source=network`;
        status.textContent = ` [ok] ${CSV_PATH} • ${rows.length} rows`;
      }catch(e){
        const {text, meta} = getCache();
        if (text){
          const raw = parseCSV(text);
          const rows = raw.map(normRow).filter(r=>!r.plan || r.plan==='VSP_choice');
          ALL = rows;
          $('version').textContent = `plan=VSP_choice • rows=${rows.length} • version=${meta?.version||'cache'} • source=cache`;
          status.textContent = ` network failed — using cached data (${rows.length} rows)`;
        } else {
          $('version').textContent = 'load error — no cache';
          status.textContent = ' load failed';
          ALL = [];
        }
      }

      compute();
    }

    /* ================== Selections & Filters ================== */
    function flags(){
      return {
        arOn: $('includeAR').checked,
        aspheric: $('includeAspheric').checked,
        oversize: $('includeOversize').checked,
        glass: $('includeGlass').checked,
        no_only: $('includeCM').checked
      };
    }

    function filterByFamSeg(rows, fam, seg){
      return rows.filter(r=>{
        const famOk = (r.family==='BOTH' || r.family===fam);
        const segVal = r.segment || 'Any';
        const segOk = (segVal==='Any' || segVal===seg || (seg==='SV' && segVal==='SV'));
        return famOk && segOk;
      });
    }

    function flagsAllow(row, f){
      for (const req of (row.requires_flags||[])){ if (!f[req]) return false; }
      for (const ban of (row.forbids_flags||[])){ if (f[ban]) return false; }
      return true;
    }

    function isSignalAddon(r){
      if ((r.exclusive_group||'').trim()) return true; // e.g., sun
      const req = r.requires_flags||[];
      return req.includes('oversize') || req.includes('no_only') || req.includes('glass');
    }

    function exclusivePick(rows){
      const win = new Map(); const pass=[];
      for (const r of rows){
        const g = r.exclusive_group||'';
        if (!g){ pass.push(r); continue; }
        const prev = win.get(g);
        if (!prev){ win.set(g,r); continue; }
        const cA=(r.copay_sv||0)+(r.copay_mf||0);
        const cB=(prev.copay_sv||0)+(prev.copay_mf||0);
        if (cA>cB) win.set(g,r);
      }
      return [...pass, ...win.values()];
    }

    function pickAR(rowsForFam, fam, f){
      if (!f.arOn) return null;
      const tiers = ['QM','QT','QV'].map(code=>{
        const r = rowsForFam.find(x => x.kind==='addon' && (x.requires_flags||[]).includes('ar') && x.code===code);
        if (!r) return null;
        const {copay, hold} = familyVals(r, fam);
        return {code, copay, hold, fee:(copay-hold), row:r};
      }).filter(Boolean);
      if (!tiers.length) return null;
      // Most profitable, tie-break lower copay
      tiers.sort((a,b)=> (b.fee - a.fee) || (a.copay - b.copay));
      return tiers[0].row;
    }

    function getBAHoldback(rowsForFam, fam){
      const ba = rowsForFam.find(r=> r.code==='BA');
      if (ba){
        const {hold} = familyVals(ba, fam);
        if (hold!=null) return hold;
      }
      return BA_HOLDBACK_DEFAULT[fam]||0;
    }

    /* ================== Bundle Build ================== */
    function rowsForLevel(rows, level){
      return {
        pair: rows.find(r=> r.kind==='pair' && r.material_level===level && r.sun!=='Polarized'),
        cr  : rows.find(r=> r.kind==='base' && r.code==='AA')
      };
    }

    function componentBreakdown(pairRow, rowsForFam, fam){
      const raw = String(pairRow?.pair_components||'').trim();
      if (!raw) return [];
      const out=[];
      raw.split(',').map(s=>s.trim().toUpperCase()).filter(Boolean).forEach(code=>{
        const r = rowsForFam.find(x=>x.code===code);
        if (!r) return;
        const {copay, hold} = familyVals(r, fam);
        out.push({code, copay, hold, fee:copay-hold});
      });
      return out;
    }

    function makeLine(row, fam){
      const {copay, hold} = familyVals(row, fam);
      return { name: row.item||row.code, code: row.code, copay, hold, fee: copay - hold, parts: [] };
    }

    function makeBundle({pair, cr, addOns, arRow, fam, level, baHold, rowsForFam}){
      const useCR = (level==='CR');
      const main = useCR ? cr : pair;
      if (!main) return null;

      const lines = [];
      // main line
      const mainLine = makeLine(main, fam);

      // embed component breakdown for composite pairs
      const comps = !useCR ? componentBreakdown(main, rowsForFam, fam) : [];
      if (comps.length){
        mainLine.parts = comps.map(c=>({ code:c.code, copay:c.copay, hold:c.hold, fee:c.fee }));
      }
      lines.push(mainLine);

      // add-ons (exclusive already resolved)
      for (const a of addOns){ lines.push(makeLine(a, fam)); }
      if (arRow) lines.push(makeLine(arRow, fam));

      // BA base holdback silently for bundles (not CR)
      let silentHold = 0;
      if (!useCR) silentHold = baHold||0;

      // totals
      const cop = lines.reduce((s,x)=>s+x.copay,0);
      const hold = lines.reduce((s,x)=>s+x.hold,0) + silentHold;
      const fee  = cop - hold;

      return { label: main.item||main.code, lines, copay: cop, holdback: hold, profit: fee };
    }

    /* ================== Compute & Render ================== */
    function tdMoney(v){ return `<td class="money">${money(v)}</td>`; }

    function renderTierCard(titleCls, bundle){
      const div=document.createElement('div'); div.className='tier';
      const nameMap = {best:'Best', better:'Better', good:'Good', cheap:'Cheapest'};
      const starMap = {best:'★★★', better:'★★', good:'★', cheap:'◎'};
      const name = nameMap[titleCls], stars=starMap[titleCls];

      if(!bundle){
        div.innerHTML=`<div class="tierHead"><div class="stars ${titleCls}"><span class="tag">${name}</span></div><div class="figures"><div class="hero">—</div><div class="caption">Patient Copay</div></div></div><div class="sub">No viable bundle</div>`;
        return div;
      }

      const head = `
        <div class="tierHead">
          <div class="stars ${titleCls}">
            <div aria-label="${name}" title="${name}" style="font-size:18px">${stars}</div>
            <span class="tag">${bundle.label}</span>
          </div>
          <div class="figures">
            <div class="hero" aria-label="Patient Copay">${money(bundle.copay)}</div>
            <div class="caption">Patient Copay</div>
            <div class="caption">Service Fee (Practice Profit): <span class="svc">${money(bundle.profit)}</span></div>
          </div>
        </div>`;

      const rowsHtml = bundle.lines.map(li=>{
        const main = `
          <tr>
            <td>${li.name}</td>
            <td class="code">${li.code||'—'}</td>
            ${tdMoney(li.copay)}
            ${tdMoney(li.hold)}
            ${tdMoney(li.fee)}
          </tr>`;

        const parts = (li.parts && li.parts.length)
          ? `
            <tr>
              <td colspan="5">
                <div class="break">
                  <table>
                    <thead>
                      <tr>
                        <th class="colhed" style="width:120px">Code</th>
                        <th class="colhed">Copay</th>
                        <th class="colhed">Holdback</th>
                        <th class="colhed">Service Fee</th>
                      </tr>
                    </thead>
                    <tbody>
                      ${li.parts.map(p=>`
                        <tr>
                          <td><span class="codepill">${p.code}</span></td>
                          ${tdMoney(p.copay)}
                          ${tdMoney(p.hold)}
                          ${tdMoney(p.fee)}
                        </tr>`).join('')}
                    </tbody>
                  </table>
                </div>
              </td>
            </tr>` : '';

        return main + parts;
      }).join('');

      div.innerHTML = head + `
        <table>
          <thead>
            <tr>
              <th>Item</th>
              <th>Code</th>
              <th class="nowrap">Copay</th>
              <th class="nowrap">Holdback</th>
              <th class="nowrap">Service Fee</th>
            </tr>
          </thead>
          <tbody>${rowsHtml}</tbody>
          <tfoot>
            <tr>
              <th colspan="2" style="text-align:right">Totals</th>
              ${tdMoney(bundle.copay)}${tdMoney(bundle.holdback)}${tdMoney(bundle.profit)}
            </tr>
          </tfoot>
        </table>`;
      return div;
    }

    function renderAll(bundles){
      const stack=$('stack'); stack.innerHTML='';
      stack.appendChild(renderTierCard('best',   bundles.best));
      stack.appendChild(renderTierCard('better', bundles.better));
      stack.appendChild(renderTierCard('good',   bundles.good));
      stack.appendChild(renderTierCard('cheap',  bundles.cheapest));
    }

    function compute(){
      if (!ALL.length){ $('stack').innerHTML=''; return; }

      const {family:fam, segment:seg} = famSegFromUI();
      const tintSel = $('lensTint').value; // clear | tinted | polarized | transitions
      const f = flags();

      // rows for family/segment
      const rowsFS = filterByFamSeg(ALL, fam, seg);

      // materials per level
      function buildForLevel(level){
        const {pair, cr} = rowsForLevel(rowsFS, level);
        const useCR = (level==='CR');

        // add-ons (oversize/glass/N-O/etc.), exclusive sun
        const signalAll = rowsFS.filter(r=> r.kind==='addon' && isSignalAddon(r) && flagsAllow(r, f));
        const sunOnly = signalAll.filter(r => (r.exclusive_group||'')==='sun');
        const notSun  = signalAll.filter(r => (r.exclusive_group||'')!=='sun');

        // choose sun by requested tint
        function chooseSun(){
          if (tintSel==='clear') return null;
          if (tintSel==='polarized'){
            // prefer 'Polarized' code in sun group for this family/seg
            return sunOnly.find(r=>/polariz/i.test(r.sun)||/polariz/i.test(r.item)) || null;
          }
          if (tintSel==='transitions'){
            // pick a photochromic option
            return sunOnly.find(r=>/photochrom/i.test(r.sun)||/photochrom/i.test(r.item)) || null;
          }
          if (tintSel==='tinted'){
            // any non photochromic/polarized tint
            return sunOnly.find(r=>/tint|solid|gradient|sunglass/i.test(r.item)) || null;
          }
          return null;
        }
        const sunPick = chooseSun();

        // AR (auto most profitable when toggle ON)
        const arRow = pickAR(rowsFS, fam, f);

        // BA base holdback for bundles
        const baHold = getBAHoldback(rowsFS, fam);

        const extras = [];
        if (sunPick) extras.push(sunPick);
        for(const a of notSun) extras.push(a);

        const pack = {pair, cr, addOns:extras, arRow, fam, level, baHold, rowsForFam:rowsFS};
        return makeBundle(pack);
      }

      // Build *all* bundles (Hi67 / Mid / Poly / CR)
      const bHi   = buildForLevel('Hi67');
      const bMid  = buildForLevel('Mid');
      const bPoly = buildForLevel('Poly');
      const bCR   = buildForLevel('CR');

      // Gather candidates, then rank into Best / Better / Good / Cheapest
      const all = [bHi,bMid,bPoly,bCR].filter(Boolean);
      if (!all.length){ renderAll({}); return; }

      const maxCopay = Math.max(...all.map(b=>b.copay));
      const chooseMostProfit = (arr)=> arr.slice().sort((a,b)=> (b.profit - a.profit) || (a.copay - b.copay))[0];
      function underCap(cap, exclude=new Set()){
        const pick = all
          .filter(b=>b.copay<=cap && !exclude.has(b.label))
          .sort((a,b)=> (b.profit - a.profit) || (a.copay - b.copay))[0];
        if (pick) return pick;
        const loose = cap / CAP_RELAX_FACTOR;
        return all
          .filter(b=>b.copay<=loose && !exclude.has(b.label))
          .sort((a,b)=> (b.profit - a.profit) || (a.copay - b.copay))[0] || null;
      }
      function cheapest(exclude=new Set()){
        return all.filter(b=>!exclude.has(b.label))
                  .sort((a,b)=> (a.copay - b.copay) || (b.profit - a.profit))[0] || null;
      }

      const best = chooseMostProfit(all);
      const used = new Set(best ? [best.label] : []);
      const better = underCap(maxCopay*BETTER_CAP_OF_MAX, used); if (better) used.add(better.label);
      let good = underCap(maxCopay*GOOD_CAP_OF_MAX, used); if (!good) good = cheapest(used); if (good) used.add(good.label);
      const cheap = cheapest(used);

      renderAll({best, better, good, cheapest:cheap});
    }

    /* ================== Wire-up ================== */
    $('forceRefresh').onclick = ()=>{ clearCache(); loadCSV(); };
    $('clearCache').onclick = ()=>{ clearCache(); $('status').textContent=' cache cleared — click Force Refresh'; };

    ['lensFamily','lensTint','includeAR','includeAspheric','includeOversize','includeGlass','includeCM']
      .forEach(id => { const node=$(id); if(node) node.onchange=compute; });

    loadCSV();
  })();
  </script>
</body>
</html>
