<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PayerEdge — VSP Bundles + OCR (Camera + Upload, section-aware)</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
<style>
  :root{
    --bg:#090e16;--bg-elev:#0c1320;--fg:#eaf1ff;--muted:#9fb0c9;--line:#263448;--accent:#72a8ff;--good:#7be0c3;
    --tier-best:#ffd166;--tier-better:#a9c2ff;--tier-good:#7be0c3;
    --radius:18px; --shadow-md:0 10px 26px rgba(0,0,0,.28); --shadow-lg:0 18px 40px rgba(0,0,0,.35);
  }
  *{box-sizing:border-box}
  body{margin:0;background:
      radial-gradient(1200px 600px at 20% -10%, rgba(90,168,255,.12), transparent 60%),
      radial-gradient(900px 500px at 110% 10%, rgba(123,224,195,.10), transparent 60%),
      var(--bg);
    color:var(--fg);font:15px/1.45 Inter,system-ui,-apple-system,"Segoe UI",Roboto,sans-serif;-webkit-font-smoothing:antialiased}
  header{position:sticky;top:0;z-index:10;display:flex;justify-content:space-between;align-items:center;
    gap:12px;padding:12px 16px;background:linear-gradient(180deg,rgba(9,14,22,.95),rgba(9,14,22,.78));
    border-bottom:1px solid var(--line);backdrop-filter:blur(10px)}
  h1{margin:0;font-weight:800;font-size:clamp(16px,1.8vw,20px)}
  .sub{color:var(--muted);font-size:12px}
  main{padding:14px}
  .bar{display:flex;flex-wrap:wrap;gap:10px 12px;align-items:center;background:linear-gradient(180deg,#0f1726,#0c1422);
    border:1px solid var(--line);border-radius:18px;padding:10px;box-shadow:var(--shadow-md)}
  .group{display:flex;gap:8px;align-items:center;padding:6px 8px;border-radius:999px;background:#0b1424}
  .btn{background:#121f35;border:1px solid var(--line);color:#fff;padding:8px 12px;border-radius:12px;cursor:pointer;font-weight:700}
  .btn:hover{background:#172845;border-color:#2f4260}
  select{background:#0e1a30;color:#fff;border:1px solid var(--line);border-radius:10px;padding:6px 8px}
  #status{margin-left:auto;padding:6px 10px;border-radius:999px;border:1px dashed var(--line);background:#0b1422;color:#c7d6ef;font-size:12px;max-width:52vw;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
  .grid{display:grid;grid-template-columns:1fr 1fr;gap:12px;margin-top:12px}
  .card{background:linear-gradient(180deg,#0f1726,#0c1422);border:1px solid var(--line);border-radius:14px;padding:10px}
  .card h3{margin:0 0 6px 0;font-size:13px;color:#cfe6ff}
  pre{white-space:pre-wrap;word-break:break-word;font:12px/1.35 ui-monospace,Menlo,Consolas,monospace;color:#bcd3ff;max-height:300px;overflow:auto;margin:0}
  .kv{display:grid;grid-template-columns:1fr auto;gap:8px 12px}
  .kv .k{color:var(--muted)} .kv .v{font-weight:800}
  @media (max-width:950px){ .grid{grid-template-columns:1fr} #status{max-width:unset} }
  /* (minimal table styles for bundles preview) */
  .tiers{display:grid;grid-template-columns:repeat(4,minmax(260px,1fr));gap:12px;margin-top:12px}
  .tier{background:linear-gradient(180deg,#0f1726,#0c1422);border:1px solid var(--line);border-radius:14px;padding:10px}
  .hero{font-weight:800;font-size:28px;color:#cfe6ff}
  .caption{color:var(--muted);font-size:12px}
  table{width:100%;border-collapse:collapse;margin-top:8px} th,td{border-bottom:1px dashed #203043;padding:6px 6px;font-size:12px}
  .money{text-align:right;font-variant-numeric:tabular-nums}
</style>
</head>
<body>
<header>
  <div>
    <h1>PayerEdge — VSP Bundles</h1>
    <div class="sub">Scoreboard shows <b>patient copay</b> and <b>service fee</b>. Sun choices are exclusive.</div>
  </div>
  <div class="sub" id="version">loading…</div>
</header>

<main>
  <div class="bar" role="toolbar" aria-label="Controls">
    <div class="group">
      <button class="btn" id="forceRefresh">Force Refresh</button>
      <button class="btn" id="clearCache">Clear Cache</button>
    </div>

    <div class="group">
      <label>Lens family
        <select id="lensFamily">
          <option value="SV" selected>Single Vision</option>
          <option value="LINED">Lined Bi/Tri</option>
          <option value="PAL">Progressive</option>
        </select>
      </label>
      <label>Lens tint
        <select id="lensTint">
          <option value="clear" selected>Clear</option>
          <option value="tinted_solid">Tinted — Solid</option>
          <option value="tinted_gradient">Tinted — Gradient</option>
          <option value="polarized">Polarized</option>
          <option value="transitions">Transitions®</option>
        </select>
      </label>
    </div>

    <div class="group">
      <label><input type="checkbox" id="includeAR" checked> Include AR (tiered)</label>
      <label><input type="checkbox" id="includeAspheric"> Aspheric</label>
      <label><input type="checkbox" id="includeOversize"> Oversize</label>
      <label><input type="checkbox" id="includeGlass"> Glass</label>
      <label><input type="checkbox" id="includeCM"> Custom measurements (N/O only)</label>
    </div>

    <div class="group">
      <button class="btn" id="scanBenefitsBtn">Scan (Camera)</button>
      <button class="btn" id="uploadBtn">Upload PDF/Image</button>
      <!-- two different inputs to avoid iOS overriding to camera when capture attr is present -->
      <input id="scanBenefitsFile" type="file" accept="image/*" capture="environment" style="display:none">
      <input id="uploadBenefitsFile" type="file" accept="application/pdf,image/*" style="display:none">
    </div>

    <span id="status" aria-live="polite">loading…</span>
  </div>

  <!-- (Optional) quick bundles preview area kept minimal to show this file is drop-in -->
  <div id="tiers" class="tiers" aria-label="Bundles Preview"></div>

  <div class="grid">
    <div class="card">
      <h3>OCR Text / PDF Text Preview</h3>
      <pre id="ocrText">—</pre>
    </div>
    <div class="card">
      <h3>Detected (used in bundles)</h3>
      <div class="kv">
        <div class="k">Materials Copay</div><div class="v" id="kv_materials">$0.00</div>
        <div class="k">Covered Enhancements → $0 copay</div><div class="v" id="kv_cov">—</div>
      </div>
    </div>
  </div>
</main>

<!-- OCR + PDF libs -->
<script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/build/pdf.min.js"></script>
<script>pdfjsLib.GlobalWorkerOptions.workerSrc="https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/build/pdf.worker.min.js";</script>

<script>
/* -------------------- helpers + surface -------------------- */
const el = (id) => document.getElementById(id);
const N  = (s) => String(s||'').toLowerCase();
const num= (v)=>{ const x=parseFloat(String(v??'').replace(/[^0-9.-]/g,'')); return isFinite(x)?x:0; };
function setStatus(s){ const n=el('status'); if(n) n.textContent = s; }
window.onerror = (m,src,line)=> setStatus('script error: '+m);

/* -------------------- CSV (minimal loader; plug your CSV filenames) -------------------- */
const CSV_CANDIDATES=[
  './vsp_choice_master_v8.4.csv',
  './data/vsp_choice_master_v8.4.csv',
  './vsp_choice_master_v7_full_fixed.csv'
];
const CACHE_KEY='rev-vsp-choice-csv-v3', META_KEY='rev-vsp-choice-meta-v3';
let DATA=[];

function parseCSV(text){
  const rows=[]; let row=[], field='', q=false;
  for(let i=0;i<text.length;i++){
    const ch=text[i];
    if(ch==='\"'){ if(q&&text[i+1]=='\"'){ field+='\"'; i++; } else { q=!q; } continue; }
    if(!q&&ch===','){ row.push(field); field=''; continue; }
    if(!q&&(ch==='\n'||ch==='\r')){ if(field!==''||row.length){ row.push(field); rows.push(row); row=[]; field=''; } continue; }
    field+=ch;
  }
  if(field!==''||row.length){ row.push(field); rows.push(row); }
  const headers = rows.shift().map(h=>h.replace(/^\"|\"$/g,'').trim());
  return rows.filter(r=>r.length>=headers.length).map(r=>{
    const o={}; headers.forEach((h,i)=>o[h]=(r[i]||'').replace(/^\"|\"$/g,'').trim()); return o;
  });
}
function quickHash(s){ let h=2166136261>>>0; for(let i=0;i<s.length;i++){ h^=s.charCodeAt(i); h=Math.imul(h,16777619)>>>0; } return ('00000000'+h.toString(16)).slice(-8); }
async function tryFetch(url){
  try{ const res=await fetch(url,{cache:'no-store'}); if(!res.ok) throw new Error('HTTP '+res.status);
       return {ok:true,text:await res.text(),url}; } catch(e){ return {ok:false,err:String(e),url}; }
}
function setCache(t,m){ localStorage.setItem(CACHE_KEY,t); localStorage.setItem(META_KEY,JSON.stringify(m)); }
function getCache(){ return {text:localStorage.getItem(CACHE_KEY), meta: JSON.parse(localStorage.getItem(META_KEY)||'{}')}; }
function clearCacheStorage(){ localStorage.removeItem(CACHE_KEY); localStorage.removeItem(META_KEY); }

async function loadCSV(){
  setStatus('loading CSV…');
  let loaded=null, tried=[];
  for(const url of CSV_CANDIDATES){ const r=await tryFetch(url); tried.push(url); if(r.ok){ loaded=r; break; } }
  if(loaded){
    const meta={plan:'VSP_choice',version:new Date().toISOString().slice(0,10)+'.ui-ocr-sections',source:'network:'+loaded.url,sha:quickHash(loaded.text)};
    setCache(loaded.text,meta); DATA=parseCSV(loaded.text); renderMeta(DATA.length,meta); setStatus(`[ok] ${loaded.url} • ${DATA.length} rows`); computeBundles(); return;
  }
  const {text,meta}=getCache();
  if(text){ DATA=parseCSV(text); renderMeta(DATA.length,{...meta,source:'cache'}); setStatus(`Network failed. Using cached data (${DATA.length} rows).`); computeBundles(); return; }
  setStatus('load failed — no CSV found ('+tried.join(', ')+')');
}
function renderMeta(count,meta){
  el('version').textContent=`plan=${meta.plan||'VSP_choice'} • rows=${count||0} • version=${meta.version||'—'} • source=${meta.source||'—'} • sha=${meta.sha||'—'}`;
}

/* -------------------- OCR / PDF wiring (separate Camera vs Upload) -------------------- */
const scanBtn  = el('scanBenefitsBtn');
const upBtn    = el('uploadBtn');
const scanIn   = el('scanBenefitsFile');     // image/* capture=environment
const uploadIn = el('uploadBenefitsFile');   // application/pdf,image/*

scanBtn.addEventListener('click', ()=> scanIn.click());
upBtn.addEventListener('click',   ()=> uploadIn.click());

scanIn.addEventListener('change',  ()=> handlePickedFile(scanIn.files?.[0], true));
uploadIn.addEventListener('change',()=> handlePickedFile(uploadIn.files?.[0], false));

async function handlePickedFile(file, isCamera){
  if(!file) return;
  try{
    setStatus(`file received (${file.type||file.name})…`);
    let text='';
    if (/pdf$/i.test(file.name) || file.type==='application/pdf'){
      text = await pdfExtractText(file).catch(()=> '');
      if(!text || text.trim().length < 40){ // fallback to OCR on page 1
        const canvas = await pdfFirstPageToCanvas(file);
        const prep = preprocess(canvas,{scale:1.8, grayscale:true, threshold:'otsu', unsharp:true});
        setStatus('reading PDF (OCR fallback)…');
        text = await runTess(prep,{psm:4});
      }
    } else {
      const canvas = await fileToCanvas(file);
      const prep1 = preprocess(canvas,{scale:1.8, grayscale:true, threshold:'otsu', unsharp:true});
      const prep2 = preprocess(canvas,{scale:1.4, grayscale:true, threshold:'sauvola', unsharp:true});
      setStatus('reading (pass 1/2)…'); const t1 = await runTess(prep1,{psm:6});
      setStatus('reading (pass 2/2)…'); const t2 = await runTess(prep2,{psm:4});
      text = chooseBestText(t1,t2); if(!text.trim()){ setStatus('fallback read…'); text = await runTess(canvas,{psm:3}); }
    }

    el('ocrText').textContent = text || '—';
    if(!text.trim()){ setStatus('no text detected'); alert('No readable text — try a clearer photo or a real PDF export.'); return; }

    setStatus('parsing benefits…');
    const b = parseBenefitsSections(text);
    OCR_STATE.materialsCents = b.materialsCopay?.cents ?? 0;
    OCR_STATE.covered = new Set(b.coveredEnhancementsKeys);

    el('kv_materials').textContent = b.materialsCopay?.raw || '$0.00';
    el('kv_cov').textContent       = b.coveredEnhancements.length? b.coveredEnhancements.join(', ') : '—';

    computeBundles();
    setStatus('scan complete');
  }catch(e){
    console.error(e); setStatus('scan failed: '+(e?.message||e)); alert('Scan failed.\n\n'+(e?.message||e));
  }finally{
    scanIn.value=''; uploadIn.value='';
  }
}

/* ---- PDF helpers ---- */
async function pdfExtractText(file){
  setStatus('extracting PDF text…');
  const buf = await file.arrayBuffer();
  const pdf = await pdfjsLib.getDocument({data:buf}).promise;
  const page = await pdf.getPage(1);
  const content = await page.getTextContent();
  const strings = content.items.map(i=>i.str).filter(Boolean);
  return (strings.join('\n') || '').trim();
}
async function pdfFirstPageToCanvas(file){
  setStatus('rendering PDF…');
  const buf = await file.arrayBuffer();
  const pdf = await pdfjsLib.getDocument({data:buf}).promise;
  const page = await pdf.getPage(1);
  const viewport = page.getViewport({scale:2.0});
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  canvas.width = viewport.width; canvas.height = viewport.height;
  await page.render({canvasContext:ctx, viewport}).promise;
  return canvas;
}

/* ---- Image preprocessing + OCR ---- */
function fileToCanvas(file){
  setStatus('loading image…');
  return new Promise((resolve,reject)=>{
    const url=URL.createObjectURL(file);
    const img=new Image();
    img.onload=()=>{ try{
      const c=document.createElement('canvas'); c.width=img.naturalWidth; c.height=img.naturalHeight;
      c.getContext('2d').drawImage(img,0,0); URL.revokeObjectURL(url); resolve(c);
    }catch(e){ URL.revokeObjectURL(url); reject(e); }};
    img.onerror=()=>{ createImageBitmap(file).then(b=>{
      const c=document.createElement('canvas'); c.width=b.width; c.height=b.height; c.getContext('2d').drawImage(b,0,0);
      URL.revokeObjectURL(url); resolve(c);
    }).catch(e=>{ URL.revokeObjectURL(url); reject(e); }); };
    img.src=url;
  });
}
function preprocess(sourceCanvas,{scale=2,grayscale=true,threshold='otsu',unsharp=true}={}){
  const w=Math.round(sourceCanvas.width*scale), h=Math.round(sourceCanvas.height*scale);
  const c=document.createElement('canvas'); c.width=w; c.height=h; const ctx=c.getContext('2d'); ctx.drawImage(sourceCanvas,0,0,w,h);
  let img=ctx.getImageData(0,0,w,h), d=img.data;
  if(grayscale){ for(let i=0;i<d.length;i+=4){ const y=0.299*d[i]+0.587*d[i+1]+0.114*d[i+2]; d[i]=d[i+1]=d[i+2]=y; } }
  if(unsharp){ const blurred=boxBlur(img,w,h,1); for(let i=0;i<d.length;i+=4){ const hp=d[i]-blurred.data[i]; const v=clamp(d[i]+hp*0.8); d[i]=d[i+1]=d[i+2]=v; } }
  if(threshold==='otsu'){ const t=otsuThreshold(img); for(let i=0;i<d.length;i+=4){ const v=d[i]>=t?255:0; d[i]=d[i+1]=d[i+2]=v; } }
  if(threshold==='sauvola'){
    const win=25,k=0.3; const g=new Uint8ClampedArray(d.length/4); for(let i=0,pi=0;i<d.length;i+=4,pi++) g[pi]=d[i];
    const mean=boxBlurGray(g,w,h,Math.floor(win/2)), std=localStd(g,mean,w,h,Math.floor(win/2));
    for(let y=0;y<h;y++){ for(let x=0;x<w;x++){ const i=y*w+x, m=mean[i], s=std[i], T=m*(1+k*((s/128)-1)); const v=g[i]>T?255:0; const di=i*4; d[di]=d[di+1]=d[di+2]=v; d[di+3]=255; } }
  }
  ctx.putImageData(img,0,0); return c;
}
function clamp(v){ return v<0?0:v>255?255:v; }
function boxBlur(imgData,w,h,r){
  const out=new ImageData(w,h), src=imgData.data, dst=out.data, tmp=new Uint32Array(w*h);
  for(let y=0;y<h;y++){ let sum=0; for(let x=0;x<w+r;x++){ if(x<w) sum+=src[(y*w+x)*4];
    if(x>=r){ const xi=x-r; tmp[y*w+xi]=sum/(Math.min(x+1,w)-Math.max(0,x-r)); }
    if(x>=2*r+1) sum-=src[(y*w+(x-2*r-1))*4]; } }
  for(let x=0;x<w;x++){ let sum=0; for(let y=0;y<h+r;y++){ if(y<h) sum+=tmp[y*w+x];
    if(y>=r){ const yi=y-r; const val=sum/(Math.min(y+1,h)-Math.max(0,y-r)); const di=(yi*w+x)*4; dst[di]=dst[di+1]=dst[di+2]=val; dst[di+3]=255; }
    if(y>=2*r+1) sum-=tmp[(y-2*r-1)*w+x]; } }
  return out;
}
function boxBlurGray(g,w,h,r){
  const out=new Uint8ClampedArray(w*h), tmp=new Float32Array(w*h);
  for(let y=0;y<h;y++){ let sum=0; for(let x=0;x<w+r;x++){ if(x<w) sum+=g[y*w+x];
    if(x>=r){ const xi=x-r; tmp[y*w+xi]=sum/(Math.min(x+1,w)-Math.max(0,x-r)); }
    if(x>=2*r+1) sum-=g[y*w+(x-2*r-1)]; } }
  for(let x=0;x<w;x++){ let sum=0; for(let y=0;y<h+r;y++){ if(y<h) sum+=tmp[y*w+x];
    if(y>=r){ const yi=y-r; out[yi*w+x]=sum/(Math.min(y+1,h)-Math.max(0,y-r)); }
    if(y>=2*r+1) sum-=tmp[(y-2*r-1)*w+x]; } }
  return out;
}
function localStd(g,mean,w,h,r){
  const out=new Uint8ClampedArray(w*h), sq=new Uint32Array(w*h);
  for(let i=0;i<g.length;i++) sq[i]=g[i]*g[i]; const meanSq=boxBlurGray(sq,w,h,r);
  for(let i=0;i<g.length;i++){ const v=Math.sqrt(Math.max(0, meanSq[i]-mean[i]*mean[i])); out[i]=v; }
  return out;
}
function otsuThreshold(imgData){
  const hist=new Array(256).fill(0), d=imgData.data; for(let i=0;i<d.length;i+=4) hist[d[i]]++;
  const total=d.length/4; let sum=0; for(let i=0;i<256;i++) sum+=i*hist[i];
  let sumB=0, wB=0, varMax=0, t=127;
  for(let i=0;i<256;i++){ wB+=hist[i]; if(!wB) continue; const wF=total-wB; if(!wF) break; sumB+=i*hist[i];
    const mB=sumB/wB, mF=(sum-sumB)/wF, v=wB*wF*(mB-mF)*(mB-mF); if(v>varMax){ varMax=v; t=i; } }
  return t;
}
async function runTess(canvasOrImage,{psm=6}={}){ const out=await Tesseract.recognize(canvasOrImage,'eng',{ tessedit_pageseg_mode:String(psm) }); return out?.data?.text || ''; }
function chooseBestText(a,b){ const score=t=>((t.match(/\$/g)||[]).length*3)+(t.length/500)-((t.match(/\b[Iil]\b/g)||[]).length); return score(a)>=score(b)?a:b; }

/* -------------------- Section-aware VSP parser -------------------- */
let OCR_STATE = { materialsCents: 0, covered: new Set() };

function centsOf(s){ if(!s) return null; const m=String(s).replace(/[^\d.]/g,''); if(!m) return null; const [a,b='0']=m.split('.'); return parseInt(a||'0',10)*100 + parseInt((b+'00').slice(0,2),10); }
function money(c){ return c==null?null:{cents:c, raw:`$${(c/100).toFixed(2)}`}; }

// Normalize a line for robust header detection
function normLine(s){ return s.replace(/\s+/g,' ').trim().toLowerCase(); }

function parseBenefitsSections(raw){
  const text=(raw||'').replace(/\r/g,'');
  const lines=text.split('\n').map(s=>s.trim()).filter(Boolean);

  // 1) Materials copay (scan local window first)
  let materials=null;
  for(let i=0;i<lines.length;i++){
    const L=lines[i];
    const m = /(?:materials?|material)\s*\$?\s*([\d,]+(?:\.\d{2})?)/i.exec(L);
    if(m){ materials = money(centsOf(m[1])); break; }
    if(/co-?payments|copayments/i.test(L)){  // look ahead a few lines
      for(let j=i;j<i+8 && j<lines.length;j++){
        const l2=lines[j], m2=/(?:materials?|material)[^$]*\$?\s*([\d,]+(?:\.\d{2})?)/i.exec(l2);
        if(m2){ materials = money(centsOf(m2[1])); break; }
      }
      if(materials) break;
    }
  }
  if(!materials) materials = money(0);

  // 2) Covered enhancements (strict sectioning)
  //    States: NONE | COVERED | COVERED_ADDL | OTHER
  const COVERED_KEYS = new Set();
  let state='NONE';
  const isHeader = (l) => {
    const n=normLine(l);
    if(/^covered$/.test(n)) return 'COVERED';
    if(/^covered with additional copay$/.test(n) || /^covered with additional co[- ]?pay$/.test(n)) return 'COVERED_ADDL';
    if(/^not covered$/.test(n) || /^excluded$/.test(n)) return 'OTHER';
    // allow “lens enhancement details …” to reset
    if(n.includes('lens enhancement details')) return 'OTHER';
    return null;
  };

  const eat = (label)=>{
    const n=normLine(label);
    if(/anti[-\s]*reflect|antireflect|\bar\b/.test(n)) COVERED_KEYS.add('ar');
    else if(/photochrom|transitions/.test(n)) COVERED_KEYS.add('photochromic');
    else if(/polariz/.test(n)) COVERED_KEYS.add('polarized');
    else if(/polycarbonate/.test(n)) COVERED_KEYS.add('polycarbonate');
    else if(/high\s*index/.test(n)) COVERED_KEYS.add('high_index');
    else if(/scratch\s*resistant/.test(n)) COVERED_KEYS.add('scratch');
    else if(/\buv\b|\buv\s*protection/.test(n)) COVERED_KEYS.add('uv');
    else if(/standard\s+progress/.test(n)) COVERED_KEYS.add('std_prog');
    else if(/premium\s+progress/.test(n)) COVERED_KEYS.add('prem_prog');
  };

  for(const L of lines){
    const h = isHeader(L);
    if(h){ state=h; continue; }
    if(state==='COVERED'){
      // treat only obvious enhancement row-ish lines (ignore empty or “notes”)
      if(/\w/.test(L) && !/copay|co[- ]?pay|notes?:?/i.test(L)){ eat(L); }
    }
    // if UNDER Covered with Additional Copay: do nothing (intentionally ignored)
  }

  const pretty = Array.from(COVERED_KEYS).map(k=>{
    return ({
      ar:'Anti-Reflective',
      photochromic:'Photochromic / Transitions',
      polarized:'Polarized',
      polycarbonate:'Polycarbonate',
      high_index:'High Index',
      scratch:'Scratch Resistant',
      uv:'UV Protection',
      std_prog:'Standard Progressives',
      prem_prog:'Premium Progressives',
    })[k] || k;
  });

  return {
    materialsCopay: materials,
    coveredEnhancements: pretty,
    coveredEnhancementsKeys: Array.from(COVERED_KEYS),
    rawText: text
  };
}

/* -------------------- Bundles (very compact preview; wire to your full logic if needed) -------------------- */
function computeBundles(){
  // This stub shows the OCR values are flowing; replace with your full bundle ranking if desired.
  const tiersEl = el('tiers'); tiersEl.innerHTML='';
  const mat = Math.max(0, OCR_STATE.materialsCents/100);
  const covered = Array.from(OCR_STATE.covered||[]);
  const tier = (name,cop,svc,rows)=>`
    <div class="tier">
      <div class="hero">$${cop.toFixed(2)}</div>
      <div class="caption">Patient Copay</div>
      <div class="caption">Service Fee (Practice Profit): <b class="good">$${svc.toFixed(2)}</b></div>
      <table>
        <thead><tr><th>Item</th><th class="money">Copay</th><th class="money">Svc Fee</th></tr></thead>
        <tbody>${rows}</tbody>
        <tfoot><tr><th style="text-align:right">Totals</th><th class="money">$${cop.toFixed(2)}</th><th class="money">$${svc.toFixed(2)}</th></tr></tfoot>
      </table>
    </div>`;
  const row = (label,c=0,s=0)=>`<tr><td>${label}</td><td class="money">$${c.toFixed(2)}</td><td class="money">$${s.toFixed(2)}</td></tr>`;

  const coveredNames = covered.map(k=>({
    ar:'Anti-Reflective',
    photochromic:'Photochromic / Transitions',
    polarized:'Polarized',
    polycarbonate:'Polycarbonate',
    high_index:'High Index',
    scratch:'Scratch Resistant',
    uv:'UV Protection',
    std_prog:'Standard Progressives',
    prem_prog:'Premium Progressives',
  }[k]||k));

  const baseRows = row('Materials Copay',mat,0) + (coveredNames.length? row('Covered Enhancements',0,0):'');
  tiersEl.innerHTML = tier('Demo', mat, 0, baseRows) +
                      tier('Demo 2', mat, 0, baseRows) +
                      tier('Demo 3', mat, 0, baseRows) +
                      tier('Demo 4', mat, 0, baseRows);
}

/* -------------------- Boot + UI wires -------------------- */
el('forceRefresh').onclick=()=>{ clearCacheStorage(); loadCSV(); };
el('clearCache').onclick =()=>{ clearCacheStorage(); setStatus('cache cleared — click Force Refresh to reload'); };

['lensFamily','lensTint','includeAR','includeAspheric','includeOversize','includeGlass','includeCM']
  .forEach(id=>{ const n=el(id); if(n) n.onchange=computeBundles; });

loadCSV(); // kick off CSV load on page open
</script>
</body>
</html>
